<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jackniu81.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Full stack engineer, focus on: Angular&#x2F;React, node.js&#x2F;.Net">
<meta property="og:type" content="website">
<meta property="og:title" content="Jack N @ GitHub">
<meta property="og:url" content="https://jackniu81.github.io/page/2/index.html">
<meta property="og:site_name" content="Jack N @ GitHub">
<meta property="og:description" content="Full stack engineer, focus on: Angular&#x2F;React, node.js&#x2F;.Net">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="Angular, React, node.js, .Net, C#">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jackniu81.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jack N @ GitHub</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jack N @ GitHub</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Full stack engineer, focus on: Angular/React, node.js/.Net</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/19/umi-is-not-recognized-as-an-internal-or-external-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/umi-is-not-recognized-as-an-internal-or-external-command/" class="post-title-link" itemprop="url">安装umi后，使用umi提示不是内部或者外部命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-19 17:00:41" itemprop="dateCreated datePublished" datetime="2021-04-19T17:00:41+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-22 09:56:56" itemprop="dateModified" datetime="2021-04-22T09:56:56+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>umi推荐使用yarn安装，安装umi后，使用umi提示不是内部或者外部命令。（’umi’ is not recognized as an internal or external command,operable program or batch file.）</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>根源在于yarn的<code>global bin</code>目录不在<code>path</code>环境变量的中，解决办法：</p>
<ol>
<li>执行<code>yarn global bin</code>, 得到<code>global bin</code>目录</li>
<li>把<code>global bin</code>目录添加到环境变量<code>path</code>中</li>
<li>测试 <code>umi -v</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/19/Github-network-issue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/Github-network-issue/" class="post-title-link" itemprop="url">解决国内不能访问github的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-19 16:31:37" itemprop="dateCreated datePublished" datetime="2021-04-19T16:31:37+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-22 09:56:56" itemprop="dateModified" datetime="2021-04-22T09:56:56+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近访问GitHub总是不稳定，经常连不上, 出各种错误(<code>OpenSSL SSL_read: Connection was reset, errno 10054</code>, <code>Connection refused</code> …)。</p>
<p>原因大概是GitHub的IP经常变化（一天可能变几次），我们本地的DNS解析有问题，解决办法就是查询github的IP，手工写到我们的<code>hosts</code>文件中。</p>
<h1 id="查询GitHub最新IP"><a href="#查询GitHub最新IP" class="headerlink" title="查询GitHub最新IP"></a>查询GitHub最新IP</h1><ol>
<li>访问 <a target="_blank" rel="noopener" href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a> </li>
<li>IP Address 即为IP地址<br><img src="https://jackniu81.github.io/img/github_ip.png" alt="github ip"></li>
</ol>
<h1 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改<code>hosts</code>文件</h1><ol>
<li>目录：C:\Windows\System32\drivers\etc</li>
<li>打开 <code>hosts</code>文件</li>
<li>结尾增加一行 <code>140.82.112.4    github.com</code>  (IP 用你查询到的最新的IP)</li>
<li>搞定，测试一下</li>
</ol>
<blockquote>
<p>说明，<code>hosts</code>文件， 可以给github.com添加多条IP记录，这样当我们访问github时，会一次尝试每个IP是否可以访问，如果都不行，会去Internet上做DNS解析。<br>可以这样配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">140.82.112.4	github.com</span><br><span class="line">140.82.113.4	github.com</span><br><span class="line">140.82.112.3	github.com</span><br><span class="line">140.82.114.4	github.com</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/18/Algorithm-Fibonacci-numbers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/Algorithm-Fibonacci-numbers/" class="post-title-link" itemprop="url">(算法) - 不使用递归，实现斐波那契数列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 15:23:09" itemprop="dateCreated datePublished" datetime="2021-04-18T15:23:09+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 16:46:17" itemprop="dateModified" datetime="2021-04-19T16:46:17+08:00">2021-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a href="https://jackniu81.github.io/2021/04/18/Algorithm-Fibonacci-numbers/">https://jackniu81.github.io/2021/04/18/Algorithm-Fibonacci-numbers/</a></p>
</blockquote>
<h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h1><p><code>斐波那契数列</code>：0, 1, 1,  2,  3, 5, 8, 13 … …  </p>
<p>通常用 F(n) 表示，形成的序列称为 <code>斐波那契数列</code> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>，F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>敏捷开发时，我们估算<code>Story Point</code>，通常就是使用斐波那契数列。</p>
<h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1. 递归"></a>2.1. 递归</h2><p>F(n) = F(n - 1) + F(n - 2)， 很简单，就不谈了。</p>
<h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2. 动态规划"></a>2.2. 动态规划</h2><p>动态规划的思想是，记录中间计算结果，计算后面相时，根据前面保存的结果直接计算，避免重复计算。</p>
<h1 id="3-Javascript-实现"><a href="#3-Javascript-实现" class="headerlink" title="3. Javascript 实现"></a>3. Javascript 实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        arr[i] = arr[i-<span class="number">1</span>] + arr[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以进一步优化，当前使用数组记录以及计算过的F(n)，由于F(n) = F(n - 1) + F(n - 2)，实际只需要记录最近的2个值即可，不需要使用数组记录全部数据。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/16/dotnet-core-interview-questions-and-answers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/dotnet-core-interview-questions-and-answers/" class="post-title-link" itemprop="url">2021 .NET/dotnet Core/C# 面试题及参考答案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-16 14:49:34" itemprop="dateCreated datePublished" datetime="2021-04-16T14:49:34+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-18 15:06:30" itemprop="dateModified" datetime="2021-04-18T15:06:30+08:00">2021-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-NET-dotnet-core-NET-framework-的关系"><a href="#1-NET-dotnet-core-NET-framework-的关系" class="headerlink" title="1. NET/dotnet core/.NET framework 的关系?"></a>1. NET/dotnet core/.NET framework 的关系?</h1><p>先看 2 张图<br>最新的.NET 5 的示意图<br><img src="https://img-blog.csdnimg.cn/20210415135448910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4ODcxNA==,size_16,color_FFFFFF,t_70#pic_center" alt=".NET 5"><br>之前的（dotnet core3.x 时代）的示意图<br><img src="https://img-blog.csdnimg.cn/20210415135513293.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4ODcxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="dotnet core .3.1 "><br>总结如下：</p>
<ol>
<li>2016 年开始，分开了.NET Framework 和.NET Core，后者开源、面向跨平台应用；</li>
<li>2019 年，.NET Framework 和.NET Core 被.NET5 完成了统一。未来只会有一个.NET，可以支持 Windows、Linux、macOS、iOS、Android、tvOS、watchOS 和 WebAssembly，等等</li>
<li>.Net standard library 是之前.NET Framework 和.NET Core 公共的部分；</li>
</ol>
<h1 id="2-corefx-coreclr-都是什么？"><a href="#2-corefx-coreclr-都是什么？" class="headerlink" title="2. corefx, coreclr 都是什么？"></a>2. corefx, coreclr 都是什么？</h1><p>dotnet 组织包含了.NET Core 的核心代码, 包括 coreclr 和 corefx 等.</p>
<ol>
<li>coreclr 是运行时代码,</li>
<li>corefx 是各种基础类库的代码. CoreFX 主要包含数个公共库，例如 System.Collections, System.IO, System.Xml 等。</li>
</ol>
<h1 id="3-asp-net-core"><a href="#3-asp-net-core" class="headerlink" title="3. asp.net core"></a>3. asp.net core</h1><h2 id="3-1-Kestrel"><a href="#3-1-Kestrel" class="headerlink" title="3.1. Kestrel"></a>3.1. Kestrel</h2><p>Kestrel 是 asp.net core 引入的跨平台的网络服务器，是默认配置。可以没有 iis, apache 和 nginx 就可以单独运行。<br>Kestrel 基于 libuv 实现；（node.js 也是基于 libuv）</p>
<h2 id="3-2-asp-net-core-主要的特性"><a href="#3-2-asp-net-core-主要的特性" class="headerlink" title="3.2. asp.net core 主要的特性"></a>3.2. asp.net core 主要的特性</h2><ol>
<li>依赖注入。</li>
<li>日志系统架构。</li>
<li>引入了一个跨平台的网络服务器，kestrel。可以没有 iis, apache 和 nginx 就可以单独运行。</li>
<li>可以使用命令行创建应用。</li>
<li>使用 AppSettings.json 来配置工程。</li>
<li>使用 start up 来注册服务。</li>
<li>更好的支持异步编程。</li>
<li>支持 web socket 和 signal IR。</li>
<li>对于跨网站的请求的预防和保护机制。</li>
</ol>
<h2 id="3-3-startup-class-的作用？"><a href="#3-3-startup-class-的作用？" class="headerlink" title="3.3. startup class 的作用？"></a>3.3. startup class 的作用？</h2><p>Startup class 是 dot net core 应用的入口。所有的 dot net core 应用必须有这个 class。这个类用来配置应用。这个类的调用是在 program main 函数里面进行配置的。类的名字可以自己定义。</p>
<h2 id="3-4-Startup-class-的-config-service-方法有什么作用"><a href="#3-4-Startup-class-的-config-service-方法有什么作用" class="headerlink" title="3.4. Startup class 的 config service 方法有什么作用?"></a>3.4. Startup class 的 config service 方法有什么作用?</h2><p>在这个方法里我们可以添加一些 service 进入依赖注入容器。</p>
<h2 id="3-5-startup-class-的-configure-方法有什么作用？"><a href="#3-5-startup-class-的-configure-方法有什么作用？" class="headerlink" title="3.5. startup class 的 configure 方法有什么作用？"></a>3.5. startup class 的 configure 方法有什么作用？</h2><p>这个方法来定义整个应用如何响应 HTTP 请求。它有几个比较重要的参数，application builder，Hosting environment, logo factory， 在这里我们可以配置一些中间件用来处理路径，验证和 session 等等。</p>
<h2 id="3-6-什么是-meta-packages？"><a href="#3-6-什么是-meta-packages？" class="headerlink" title="3.6. 什么是 meta packages？"></a>3.6. 什么是 meta packages？</h2><p>Meta packages 是指包含所有 ASP dot net code 依赖的一个包。叫做 Microsoft.AspNetCore.All</p>
<h2 id="3-7-什么是中间件？"><a href="#3-7-什么是中间件？" class="headerlink" title="3.7. 什么是中间件？"></a>3.7. 什么是中间件？</h2><p>中间件在这里是指注入到应用中处理请求和响应的组件。asp.net core 的中间件模型也是洋葱模型（和 node.js d Koa 一样）</p>
<h2 id="3-8-application-builder-的-use-和-run-方法有什么区别？"><a href="#3-8-application-builder-的-use-和-run-方法有什么区别？" class="headerlink" title="3.8. application builder 的 use 和 run 方法有什么区别？"></a>3.8. application builder 的 use 和 run 方法有什么区别？</h2><p>这两个方法都在 start up class 的 configure 方法里面调用。都是用来向应用请求管道里面添加中间件的。Use 方法可以调用下一个中间件的添加，而 run 不会。</p>
<h2 id="3-9-dot-net-core-管道（pipeline）里面的-map-拓展有什么作用"><a href="#3-9-dot-net-core-管道（pipeline）里面的-map-拓展有什么作用" class="headerlink" title="3.9. dot net core 管道（pipeline）里面的 map 拓展有什么作用?"></a>3.9. dot net core 管道（pipeline）里面的 map 拓展有什么作用?</h2><p>可以针对不同的路径添加不同的中间件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span><span class="params">(IApplicationBuilder app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  app.Map(<span class="string">&quot;/path1&quot;</span>, Middleware1);</span><br><span class="line">  app.Map(<span class="string">&quot;/path2&quot;</span>, Middleware2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-如何在-dot-net-core-中激活-session-功能"><a href="#3-10-如何在-dot-net-core-中激活-session-功能" class="headerlink" title="3.10. 如何在 dot net core 中激活 session 功能?"></a>3.10. 如何在 dot net core 中激活 session 功能?</h2><ol>
<li>首先要添加 session 包.</li>
<li>其次要在 config service 方法里面添加 session。</li>
<li>然后又在 configure 方法里面调用 usesession。</li>
</ol>
<h2 id="3-11-如何在-controller-中注入-service"><a href="#3-11-如何在-controller-中注入-service" class="headerlink" title="3.11. 如何在 controller 中注入 service?"></a>3.11. 如何在 controller 中注入 service?</h2><p>依赖注入的思想：</p>
<ol>
<li>在 config services 方法中配置这个 service。</li>
<li>在 controller 的构造函数中，添加这个依赖注入。</li>
</ol>
<h2 id="3-12-dot-net-core-里面的路径是如何处理的？"><a href="#3-12-dot-net-core-里面的路径是如何处理的？" class="headerlink" title="3.12. dot net core 里面的路径是如何处理的？"></a>3.12. dot net core 里面的路径是如何处理的？</h2><p>路径处理是用来为进入的请求寻找处理函数的机制。所有的路径在函数运行开始时进行注册。</p>
<p>主要有两种路径处理方式:</p>
<ol>
<li>常规路径处理就是用 MapRoute 的方式设定调用路径</li>
<li>属性路径处理是指在调用函数的上方设定一个路径属性。</li>
</ol>
<h2 id="3-13-application-builder-的-use-和-run-方法有什么区别？"><a href="#3-13-application-builder-的-use-和-run-方法有什么区别？" class="headerlink" title="3.13. application builder 的 use 和 run 方法有什么区别？"></a>3.13. application builder 的 use 和 run 方法有什么区别？</h2><p>这两个方法都在 start up class 的 configure 方法里面调用。都是用来向应用请求管道里面添加中间件的。Use 方法可以调用下一个中间件的添加，而 run 不会。</p>
<h2 id="3-14-依赖注入后的服务生命周期"><a href="#3-14-依赖注入后的服务生命周期" class="headerlink" title="3.14. 依赖注入后的服务生命周期?"></a>3.14. 依赖注入后的服务生命周期?</h2><p>在 dot net core 中，我们不需要关心如何释放这些服务, 因为系统会帮我们释放掉。有三种服务的生命周期。</p>
<ol>
<li>单实例服务， 通过 add singleton 方法来添加。在注册时即创建服务, 在随后的请求中都使用这一个服务。</li>
<li>短暂服务, 通过 add transient 方法来添加。是一种轻量级的服务，用于无状态服务的操作。</li>
<li>作用域服务，一个新的请求会创建一个服务实例。使用 add scoped 方法来添加。</li>
</ol>
<h2 id="3-15-什么么是-Razor-页面"><a href="#3-15-什么么是-Razor-页面" class="headerlink" title="3.15. 什么么是 Razor 页面?"></a>3.15. 什么么是 Razor 页面?</h2><p>是 dot net core 中支持 ASP 网页表格的一种开发模型。@page 作为页面的起始标志。可以看做是 asp.net core 使用的模板引擎。</p>
<h2 id="3-16-如何在-Razor-页面中实现数据模型绑定"><a href="#3-16-如何在-Razor-页面中实现数据模型绑定" class="headerlink" title="3.16. 如何在 Razor 页面中实现数据模型绑定?"></a>3.16. 如何在 Razor 页面中实现数据模型绑定?</h2><p>使用 bindproperty 属性。</p>
<h2 id="3-17-Server-Transfer-和-Response-Redirect-的区别是什么"><a href="#3-17-Server-Transfer-和-Response-Redirect-的区别是什么" class="headerlink" title="3.17. Server.Transfer 和 Response.Redirect 的区别是什么"></a>3.17. Server.Transfer 和 Response.Redirect 的区别是什么</h2><ol>
<li>Server.Transfer 仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；</li>
<li>Response.Redirect 则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。</li>
</ol>
<h2 id="3-18-API，什么时候用-Get-Post-Put-Delete"><a href="#3-18-API，什么时候用-Get-Post-Put-Delete" class="headerlink" title="3.18. API，什么时候用 Get/Post/Put/Delete"></a>3.18. API，什么时候用 Get/Post/Put/Delete</h2><ol>
<li>GET： 查询</li>
<li>POST ：创建对象</li>
<li>PUT： 修改对象</li>
<li>DELETE：删除</li>
</ol>
<h1 id="4-C"><a href="#4-C" class="headerlink" title="4. C#"></a>4. C#</h1><h2 id="4-1-一个单例（Singleton）类"><a href="#4-1-一个单例（Singleton）类" class="headerlink" title="4.1. 一个单例（Singleton）类"></a>4.1. 一个单例（Singleton）类</h2><p>单线程下的简单实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MySingleton</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">// 禁止被实例化</span></span><br><span class="line">  <span class="keyword">public</span> readonly <span class="keyword">static</span> MySingletonInstance = <span class="keyword">new</span> MySingleton();	<span class="comment">// 程序加载时就会初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全的加锁双检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MySingleton _instance = null;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> readonly object SynObject = <span class="keyword">new</span> object();</span><br><span class="line"></span><br><span class="line">    MySingleton() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (null == _instance)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (SynObject)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (null == _instance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _instance = <span class="keyword">new</span> MySingleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-abstract-class-和-interface-有什么区别"><a href="#4-2-abstract-class-和-interface-有什么区别" class="headerlink" title="4.2. abstract class 和 interface 有什么区别?"></a>4.2. abstract class 和 interface 有什么区别?</h2><p>相同点：都不能被直接实例化，都可以通过继承实现其抽象方法。</p>
<p>不同点：</p>
<ol>
<li>接口支持多继承；抽象类不能实现多继承。</li>
<li>接口只能定义行为；抽象类既可以定义行为，还可能提供实现。</li>
<li>接口只包含方法(Method)、属性(Property)、索引器(Index)、事件(Event)的签名，但不能定义字段和包含实现的方法；</li>
<li>抽象类可以定义字段、属性、包含有实现的方法。</li>
</ol>
<h2 id="4-3-是否可以继承-String-类"><a href="#4-3-是否可以继承-String-类" class="headerlink" title="4.3. 是否可以继承 String 类?"></a>4.3. 是否可以继承 String 类?</h2><p>String 类是 sealed 类故不可以继承。</p>
<h2 id="4-4-StringBuilder-和-String-的区别？"><a href="#4-4-StringBuilder-和-String-的区别？" class="headerlink" title="4.4. StringBuilder 和 String 的区别？"></a>4.4. StringBuilder 和 String 的区别？</h2><p>String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder，不要使用 String。<br>但是简单的字符拼接，String 还是首选。（100？次以内用 String，以上用 StringBuilder）</p>
<h2 id="4-5-什么情况下会用到虚方法？它与接口有什么不同？"><a href="#4-5-什么情况下会用到虚方法？它与接口有什么不同？" class="headerlink" title="4.5. 什么情况下会用到虚方法？它与接口有什么不同？"></a>4.5. 什么情况下会用到虚方法？它与接口有什么不同？</h2><ol>
<li>子类重新定义父类的某一个方法时，必须把父类的方法定义为 virtual</li>
<li>在定义接口中不能有方法体，虚方法可以。</li>
<li>实现时,子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。</li>
</ol>
<h2 id="4-6-string、String；int、Int32；Boolean、bool-的区别"><a href="#4-6-string、String；int、Int32；Boolean、bool-的区别" class="headerlink" title="4.6. string、String；int、Int32；Boolean、bool 的区别"></a>4.6. string、String；int、Int32；Boolean、bool 的区别</h2><p>String、Int32、Boolean 等都属于.Net 中定义的类，而 string、int、bool 相当于 C#中对这些类定义的别名。CTS。</p>
<h2 id="4-7-private、-protected、-public、-internal-修饰符的访问权限。"><a href="#4-7-private、-protected、-public、-internal-修饰符的访问权限。" class="headerlink" title="4.7. private、 protected、 public、 internal 修饰符的访问权限。"></a>4.7. private、 protected、 public、 internal 修饰符的访问权限。</h2><ol>
<li>private : 私有成员, 在类的内部才可以访问。</li>
<li>protected : 保护成员，该类内部和继承类中可以访问。</li>
<li>public : 公共成员，完全公开，没有访问限制。</li>
<li>internal: 当前程序集内可以访问。</li>
</ol>
<h2 id="4-8-C-中的委托是什么？事件是不是一种委托？事件和委托的关系。"><a href="#4-8-C-中的委托是什么？事件是不是一种委托？事件和委托的关系。" class="headerlink" title="4.8. C#中的委托是什么？事件是不是一种委托？事件和委托的关系。"></a>4.8. C#中的委托是什么？事件是不是一种委托？事件和委托的关系。</h2><p>委托可以把一个方法作为参数代入另一个方法，可以理解为指向一个函数的指针。<br>换个说法来解释，委托就是函数指针，事件就是保存多个函数指针的数组。</p>
<p>事件和委托的区别如下：</p>
<ol>
<li>事件只能在方法的外部进行声明，而委在方法的外部和内部都可以声明。</li>
<li>事件只能在类的内部触发，不能在类的外部触发。而委托在类的内部和外都都可以触发。</li>
<li>委托一般用于回调，而事件用于外部接口。例如在观察者模式中，在被观察者中可以声明一个事件作为外部观察者注册的接口。</li>
</ol>
<h2 id="4-9-override-与重载（overload）的区别"><a href="#4-9-override-与重载（overload）的区别" class="headerlink" title="4.9. override 与重载（overload）的区别"></a>4.9. override 与重载（overload）的区别</h2><ol>
<li>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。</li>
<li>Override 是进行基类中函数的重写。Override 是面向对象的概念</li>
</ol>
<h2 id="4-10-什么是装箱-boxing-和拆箱-unboxing"><a href="#4-10-什么是装箱-boxing-和拆箱-unboxing" class="headerlink" title="4.10. 什么是装箱(boxing)和拆箱(unboxing)"></a>4.10. 什么是装箱(boxing)和拆箱(unboxing)</h2><p>装箱：从值类型接口转换到引用类型。<br>拆箱：从引用类型转换到值类型。</p>
<p>——–END——–</p>
<blockquote>
<p>参考:<br><a target="_blank" rel="noopener" href="https://www.webtrainingroom.com/interview/asp-net-core-interview-questions-answers">https://www.webtrainingroom.com/interview/asp-net-core-interview-questions-answers</a> &gt; <a target="_blank" rel="noopener" href="https://www.talkingdotnet.com/asp-net-core-interview-questions/">https://www.talkingdotnet.com/asp-net-core-interview-questions/</a></p>
</blockquote>
<blockquote>
<p>—————- END —————-</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/12/Vue-js-Interview-Questions-and-Answers-2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/Vue-js-Interview-Questions-and-Answers-2021/" class="post-title-link" itemprop="url">2021 Vue.js 面试题汇总及答案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 15:10:23" itemprop="dateCreated datePublished" datetime="2021-04-12T15:10:23+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-14 13:36:52" itemprop="dateModified" datetime="2021-04-14T13:36:52+08:00">2021-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">1. 基本问题</a><ul>
<li><a href="#11-vuejs-%E7%9A%84%E7%89%B9%E7%82%B9">1.1. Vue.js 的特点</a></li>
<li><a href="#12-vuejs-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">1.2. Vue.js 双向绑定的原理</a></li>
<li><a href="#13-vuejs-30-%E6%94%BE%E5%BC%83defineproperty-%E4%BD%BF%E7%94%A8proxy%E7%9A%84%E5%8E%9F%E5%9B%A0">1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因</a></li>
<li><a href="#14-vue-2-%E4%B8%AD%E7%BB%99-data-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</a></li>
<li><a href="#15-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB">1.5. Computed和Watch的区别</a></li>
<li><a href="#16-computed-%E5%92%8C-methods-%E7%9A%84%E5%8C%BA%E5%88%AB">1.6. Computed 和 Methods 的区别</a></li>
<li><a href="#17-%E8%99%9A%E6%8B%9Fdomdiff%E7%AE%97%E6%B3%95">1.7. 虚拟DOM，diff算法</a></li>
<li><a href="#18-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81virtual-dom">1.8. 为何需要Virtual DOM？</a></li>
<li><a href="#19-%E8%BF%87%E6%BB%A4%E5%99%A8-filter">1.9. 过滤器 (Filter)</a></li>
<li><a href="#110-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8">1.10. 常见的事件修饰符及其作用</a></li>
<li><a href="#111-v-show%E6%8C%87%E4%BB%A4%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">1.11. v-show指令和v-if指令的区别是什么？</a></li>
<li><a href="#112-v-model-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88">1.12. v-model 是如何实现的，语法糖实际是什么</a></li>
<li><a href="#113-data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1">1.13. data为什么是一个函数而不是对象</a></li>
<li><a href="#114-vue-template-%E5%88%B0-render-%E7%9A%84%E8%BF%87%E7%A8%8B">1.14. Vue template 到 render 的过程</a></li>
<li><a href="#115-vue-data-%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%8E%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%97">1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></li>
<li><a href="#116-axios%E6%98%AF%E4%BB%80%E4%B9%88">1.16. axios是什么</a></li>
<li><a href="#117-sass%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">1.17. sass是什么？如何在vue中安装和使用？</a></li>
<li><a href="#118-vuejs%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81">1.18. Vue.js页面闪烁</a></li>
<li><a href="#119-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%A4%AA%E6%B7%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.19. 如何解决数据层级结构太深的问题</a></li>
<li><a href="#120-%E5%9C%A8-vue-js%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%B0%83%E7%94%A8api%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%B7%A8%E5%9F%9F">1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域</a></li>
<li><a href="#121-%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5">1.21. 批量异步更新策略</a></li>
<li><a href="#122-vue-%E7%9A%84-nexttick-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.22. vue 的 nextTick 方法的实现原理</a></li>
<li><a href="#123-vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0-">1.23. Vue 组件 data 为什么必须是函数 ?</a></li>
<li><a href="#124-v-if%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">1.24. v-if和v-for一起使用的弊端及解决办法</a></li>
<li><a href="#125-vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">1.25. vue常用指令</a></li>
<li><a href="#126-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">1.26. 组件传值方式有哪些</a></li>
<li><a href="#127-vue-loader%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E5%93%AA%E4%BA%9B">1.27. vue-loader是什么？使用它的用途有哪些？</a></li>
</ul>
</li>
<li><a href="#2-%E7%BB%84%E4%BB%B6-component">2. 组件 Component</a><ul>
<li><a href="#21-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6-%E7%BC%96%E5%86%99%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%88%99">2.1. vue中如何编写可复用的组件 （编写组件的原则）</a></li>
<li><a href="#22-%E5%A6%82%E4%BD%95%E8%AE%A9css%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B5%B7%E4%BD%9C%E7%94%A8">2.2. 如何让CSS只在当前组件中起作用？</a></li>
<li><a href="#23-keep-alive%E6%98%AF%E4%BB%80%E4%B9%88">2.3. keep-alive是什么？</a></li>
<li><a href="#24-%E5%A6%82%E4%BD%95%E5%9C%A8-vue-js%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">2.4. 如何在 Vue. js动态插入图片</a></li>
<li><a href="#25-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F">2.5. 父子组件的生命周期顺序</a></li>
</ul>
</li>
<li><a href="#3-vuex">3. Vuex</a><ul>
<li><a href="#31-vuex%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">3.1. vuex的核心概念</a></li>
<li><a href="#32-vuex%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E5%AE%83">3.2. vuex是什么？怎么使用？哪种功能场景使用它？</a></li>
<li><a href="#33-%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E6%8B%86%E5%88%86%E5%90%84%E8%87%AA%E7%9A%84state%E6%AF%8F%E5%9D%97%E5%B0%8F%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8A%B6%E6%80%81%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%AC%E5%85%B1%E7%9A%84%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%B4%E6%8A%A4%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83%E8%BF%99%E5%9D%97">3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块</a></li>
</ul>
</li>
<li><a href="#4-router">4. Router</a><ul>
<li><a href="#41-vue-router%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F">4.1. vue-router路由的两种模式</a></li>
<li><a href="#42-vue-router%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">4.2. vue-router如何定义嵌套路由</a></li>
<li><a href="#43-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90">4.3. vue-router有哪几种导航钩子？</a></li>
<li><a href="#44-route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB">4.4. $route和$router的区别</a></li>
<li><a href="#45-%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F">4.5. 路由之间跳转的方式</a></li>
<li><a href="#46-active-class%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7">4.6. active-class是哪个组件的属性</a></li>
</ul>
</li>
</ul>
<h1 id="1-基本问题"><a href="#1-基本问题" class="headerlink" title="1. 基本问题"></a>1. 基本问题</h1><h2 id="1-1-Vue-js-的特点"><a href="#1-1-Vue-js-的特点" class="headerlink" title="1.1. Vue.js 的特点"></a>1.1. Vue.js 的特点</h2><ul>
<li>易用： 简单，易学，上手快</li>
<li>灵活： （渐进式）不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</li>
<li>高效： 20kB min+gzip 运行大小；超快虚拟 DOM；最省心的优化</li>
<li>双向绑定：开发效率高</li>
<li>基于组件的代码共享</li>
<li>Web项目工程化，增加可读性、可维护性</li>
</ul>
<h2 id="1-2-Vue-js-双向绑定的原理"><a href="#1-2-Vue-js-双向绑定的原理" class="headerlink" title="1.2. Vue.js 双向绑定的原理"></a>1.2. Vue.js 双向绑定的原理</h2><p>Vue.js 2.0  采用数据劫持（Proxy 模式）结合发布者-订阅者模式（PubSub 模式）的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<blockquote>
<p>Vue.js 3.0, 放弃了Object.defineProperty ，使用更快的ES6原生 Proxy (访问对象拦截器, 也称代理器)</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
</li>
<li><p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
</li>
<li><p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
</li>
<li><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
</li>
</ol>
<h2 id="1-3-Vue-js-3-0-放弃defineProperty-使用Proxy的原因"><a href="#1-3-Vue-js-3-0-放弃defineProperty-使用Proxy的原因" class="headerlink" title="1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因"></a>1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因</h2><p>Object.defineProperty缺陷</p>
<ol>
<li>监控到数组下标的变化时，开销很大。所以Vue.js放弃了下标变化的检测；</li>
<li>Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。Object.defineProperty需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</li>
<li>Object.defineProperty对新增属性需要手动进行Observe。vue2时需要使用 vm.$set 才能保证新增的属性也是响应式</li>
<li>Proxy支持13种拦截操作，这是defineProperty所不具有的</li>
<li>Proxy 作为新标准，长远来看，JS引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化</li>
</ol>
<h2 id="1-4-Vue-2-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#1-4-Vue-2-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a>1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h2><p>视图并未刷新。这是因为在Vue实例创建时，新属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：<code>this.$set(this.obj, &#39;new_property&#39;, &#39;new_value&#39;)</code></p>
<h2 id="1-5-Computed和Watch的区别"><a href="#1-5-Computed和Watch的区别" class="headerlink" title="1.5. Computed和Watch的区别"></a>1.5. Computed和Watch的区别</h2><ol>
<li>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。</li>
</ol>
<blockquote>
<p>运用场景：</p>
</blockquote>
<ol>
<li>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</li>
<li>多个因素影响一个显示，用Computed；一个因素的变化影响多个其他因素、显示，用Watch;</li>
</ol>
<h2 id="1-6-Computed-和-Methods-的区别"><a href="#1-6-Computed-和-Methods-的区别" class="headerlink" title="1.6. Computed 和 Methods 的区别"></a>1.6. Computed 和 Methods 的区别</h2><ol>
<li>computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，</li>
<li>method 调用总会执行该函数</li>
</ol>
<h2 id="1-7-虚拟DOM，diff算法"><a href="#1-7-虚拟DOM，diff算法" class="headerlink" title="1.7. 虚拟DOM，diff算法"></a>1.7. 虚拟DOM，diff算法</h2><p>（1）让我们不用直接操作DOM元素，只操作数据便可以重新渲染页面<br>（2）虚拟dom是为了解决浏览器性能问题而被设计出来的<br>当操作数据时，将改变的dom元素缓存起来，都计算完后再通过比较映射到真实的dom树上<br>（3）diff算法比较新旧虚拟dom。如果节点类型相同，则比较数据，修改数据；如果节点不同，直接干掉节点及所有子节点，插入新的节点；如果给每个节点都设置了唯一的key，就可以准确的找到需要改变的内容，否则就会出现修改一个地方导致其他地方都改变的情况。比如A-B-C-D, 我要插入新节点A-B-M-C-D,实际上改变的了C和D。但是设置了key，就可以准确的找到B C并插入</p>
<h2 id="1-8-为何需要Virtual-DOM？"><a href="#1-8-为何需要Virtual-DOM？" class="headerlink" title="1.8. 为何需要Virtual DOM？"></a>1.8. 为何需要Virtual DOM？</h2><ol>
<li>具备跨平台的优势</li>
<li>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。</li>
<li>提升渲染性能</li>
</ol>
<h2 id="1-9-过滤器-Filter"><a href="#1-9-过滤器-Filter" class="headerlink" title="1.9. 过滤器 (Filter)"></a>1.9. 过滤器 (Filter)</h2><p>在Vue中使用filters来过滤(格式化)数据，filters不会修改数据，而是过滤(格式化)数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示。<br>使用场景： 比如需要处理时间、数字等的的显示格式；</p>
<h2 id="1-10-常见的事件修饰符及其作用"><a href="#1-10-常见的事件修饰符及其作用" class="headerlink" title="1.10. 常见的事件修饰符及其作用"></a>1.10. 常见的事件修饰符及其作用</h2><ol>
<li><code>.stop</code>：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li>
<li><code>.prevent</code> ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li><code>.capture</code> ：当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。如 div1中嵌套div2中嵌套div3.capture中嵌套div4，那么执行顺序为：div3=》div4=》div2=》div1</li>
<li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li><code>.once</code> ：只会触发一次。</li>
</ol>
<h2 id="1-11-v-show指令和v-if指令的区别是什么？"><a href="#1-11-v-show指令和v-if指令的区别是什么？" class="headerlink" title="1.11. v-show指令和v-if指令的区别是什么？"></a>1.11. v-show指令和v-if指令的区别是什么？</h2><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
<h2 id="1-12-v-model-是如何实现的，语法糖实际是什么"><a href="#1-12-v-model-是如何实现的，语法糖实际是什么" class="headerlink" title="1.12. v-model 是如何实现的，语法糖实际是什么"></a>1.12. v-model 是如何实现的，语法糖实际是什么</h2><ol>
<li>作用在表单元素上<code>v-model=&quot;message&quot;</code>等同于<code>v-bind:value=&quot;message&quot;  v-on:input=&quot;message=$event.target.value&quot;</code></li>
<li>作用在组件上, 本质是一个父子组件通信的语法糖，通过prop和$.emit实现, 等同于<code>:value=&quot;message&quot; @input=&quot; $emit(&#39;input&#39;, $event.target.value)&quot;</code></li>
</ol>
<h2 id="1-13-data为什么是一个函数而不是对象"><a href="#1-13-data为什么是一个函数而不是对象" class="headerlink" title="1.13. data为什么是一个函数而不是对象"></a>1.13. data为什么是一个函数而不是对象</h2><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h2 id="1-14-Vue-template-到-render-的过程"><a href="#1-14-Vue-template-到-render-的过程" class="headerlink" title="1.14. Vue template 到 render 的过程"></a>1.14. Vue template 到 render 的过程</h2><ol>
<li>调用parse方法将template转化为ast（抽象语法树, abstract syntax tree）</li>
<li>对静态节点做优化。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</li>
<li>生成渲染函数. 渲染的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名，子节点，文本等等）</li>
</ol>
<h2 id="1-15-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#1-15-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h2><p>不会立即同步执行重新渲染。<br>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。<br>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<br>然后，在下一个的事件循环”tick”中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h2 id="1-16-axios是什么"><a href="#1-16-axios是什么" class="headerlink" title="1.16. axios是什么"></a>1.16. axios是什么</h2><p>易用、简洁且高效的http库， 支持node端和浏览器端，支持Promise，支持拦截器等高级配置。</p>
<h2 id="1-17-sass是什么？如何在vue中安装和使用？"><a href="#1-17-sass是什么？如何在vue中安装和使用？" class="headerlink" title="1.17. sass是什么？如何在vue中安装和使用？"></a>1.17. sass是什么？如何在vue中安装和使用？</h2><p>sass是一种CSS预编译语言安装和使用步骤如下。</p>
<ol>
<li>用npm安装加载程序（ sass-loader、 css-loader等加载程序)。</li>
<li>在 webpack.config.js中配置sass加载程序。</li>
</ol>
<h2 id="1-18-Vue-js页面闪烁"><a href="#1-18-Vue-js页面闪烁" class="headerlink" title="1.18. Vue.js页面闪烁"></a>1.18. Vue.js页面闪烁</h2><p>Vue. js提供了一个v-cloak指令，该指令一直保持在元素上，直到关联实例结束编译。当和CSS一起使用时，这个指令可以隐藏未编译的标签，直到实例编译结束。用法如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak]&#123; </span><br><span class="line"> display:none; </span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-19-如何解决数据层级结构太深的问题"><a href="#1-19-如何解决数据层级结构太深的问题" class="headerlink" title="1.19. 如何解决数据层级结构太深的问题"></a>1.19. 如何解决数据层级结构太深的问题</h2><p>在开发业务时，经常会岀现异步获取数据的情况，有时数据层次比较深，如以下代码: <code>span &#39;v-text=&quot;a.b.c.d&quot;&gt;&lt;/span&gt;</code>, 可以使用vm.$set手动定义一层数据: <code>vm.$set(&quot;demo&quot;，a.b.c.d)</code></p>
<h2 id="1-20-在-Vue-js开发环境下调用API接口，如何避免跨域"><a href="#1-20-在-Vue-js开发环境下调用API接口，如何避免跨域" class="headerlink" title="1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域"></a>1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域</h2><p>config/ index.js内对 proxyTable项配置代理。</p>
<h2 id="1-21-批量异步更新策略"><a href="#1-21-批量异步更新策略" class="headerlink" title="1.21. 批量异步更新策略"></a>1.21. 批量异步更新策略</h2><p>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>换句话说，只要观察到数据变化，就会自动开启一个队列，并缓冲在同一个事件循环中发生的所以数据改变。在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。</p>
<h2 id="1-22-vue-的-nextTick-方法的实现原理"><a href="#1-22-vue-的-nextTick-方法的实现原理" class="headerlink" title="1.22. vue 的 nextTick 方法的实现原理"></a>1.22. vue 的 nextTick 方法的实现原理</h2><ol>
<li>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行</li>
<li>microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li>
</ol>
<h2 id="1-23-Vue-组件-data-为什么必须是函数"><a href="#1-23-Vue-组件-data-为什么必须是函数" class="headerlink" title="1.23. Vue 组件 data 为什么必须是函数 ?"></a>1.23. Vue 组件 data 为什么必须是函数 ?</h2><p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>
<h2 id="1-24-v-if和v-for一起使用的弊端及解决办法"><a href="#1-24-v-if和v-for一起使用的弊端及解决办法" class="headerlink" title="1.24. v-if和v-for一起使用的弊端及解决办法"></a>1.24. v-if和v-for一起使用的弊端及解决办法</h2><p>由于v-for的优先级比v-if高，所以导致每循环一次就会去v-if一次，而v-if是通过创建和销毁dom元素来控制元素的显示与隐藏，所以就会不停的去创建和销毁元素，造成页面卡顿，性能下降。</p>
<p>解决办法：</p>
<ol>
<li>在v-for的外层或内层包裹一个元素来使用v-if</li>
<li>用computed处理</li>
</ol>
<h2 id="1-25-vue常用指令"><a href="#1-25-vue常用指令" class="headerlink" title="1.25. vue常用指令"></a>1.25. vue常用指令</h2><ol>
<li>v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）</li>
<li>v-bind 动态绑定 作用： 及时对页面的数据进行更改</li>
<li>v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li>
<li>v-for 格式： v-for=”字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)</li>
<li>v-show 显示内容 （同angular中的ng-show）</li>
<li>v-hide 隐藏内容（同angular中的ng-hide）</li>
<li>v-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）</li>
<li>v-else-if 必须和v-if连用</li>
<li>v-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误</li>
<li>v-text 解析文本</li>
<li>v-html 解析html标签</li>
<li>v-bind:class 三种绑定方法 1、对象型 ‘{red:isred}’ 2、三元型 ‘isred?”red”:”blue”‘ 3、数组型 ‘[{red:”isred”},{blue:”isblue”}]’</li>
<li>v-once 进入页面时 只渲染一次 不在进行渲染</li>
<li>v-cloak 防止闪烁</li>
<li>v-pre 把标签内部的元素原位输出</li>
</ol>
<h2 id="1-26-组件传值方式有哪些"><a href="#1-26-组件传值方式有哪些" class="headerlink" title="1.26. 组件传值方式有哪些"></a>1.26. 组件传值方式有哪些</h2><ol>
<li>父传子：子组件通过props[‘xx’] 来接收父组件传递的属性 xx 的值</li>
<li>子传父：子组件通过 this.$emit(‘fnName’,value) 来传递,父组件通过接收 fnName 事件方法来接收回调</li>
<li>其他方式：通过创建一个bus，进行传值</li>
<li>使用Vuex</li>
</ol>
<h2 id="1-27-vue-loader是什么？使用它的用途有哪些？"><a href="#1-27-vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="1.27. vue-loader是什么？使用它的用途有哪些？"></a>1.27. vue-loader是什么？使用它的用途有哪些？</h2><h1 id="2-组件-Component"><a href="#2-组件-Component" class="headerlink" title="2. 组件 Component"></a>2. 组件 Component</h1><h2 id="2-1-vue中如何编写可复用的组件-（编写组件的原则）"><a href="#2-1-vue中如何编写可复用的组件-（编写组件的原则）" class="headerlink" title="2.1. vue中如何编写可复用的组件 （编写组件的原则）"></a>2.1. vue中如何编写可复用的组件 （编写组件的原则）</h2><ol>
<li>以组件功能命名</li>
<li>只负责ui的展示和交互动画，不要在组件里与服务器打交道（获取异步数据等）</li>
<li>可复用组件不会因组件使用的位置、场景而变化。尽量减少对外部条件的依赖。</li>
</ol>
<h2 id="2-2-如何让CSS只在当前组件中起作用？"><a href="#2-2-如何让CSS只在当前组件中起作用？" class="headerlink" title="2.2. 如何让CSS只在当前组件中起作用？"></a>2.2. 如何让CSS只在当前组件中起作用？</h2><p>在每一个Vue.js组件中都可以定义各自的CSS、 JavaScript代码。如果希望组件内写的CSS只对当前组件起作用，只需要在Style标签添加Scoped属性，即<style scoped></style>。</p>
<h2 id="2-3-keep-alive是什么？"><a href="#2-3-keep-alive是什么？" class="headerlink" title="2.3. keep-alive是什么？"></a>2.3. keep-alive是什么？</h2><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>两个重要属性，include 缓存组件名称，exclude 不需要缓存的组件名称。</p>
<h2 id="2-4-如何在-Vue-js动态插入图片"><a href="#2-4-如何在-Vue-js动态插入图片" class="headerlink" title="2.4. 如何在 Vue. js动态插入图片"></a>2.4. 如何在 Vue. js动态插入图片</h2><p>对“src”属性插值将导致404请求错误。应使用 v-bind:src （简写<code>:src</code>）格式代替。</p>
<h2 id="2-5-父子组件的生命周期顺序"><a href="#2-5-父子组件的生命周期顺序" class="headerlink" title="2.5. 父子组件的生命周期顺序"></a>2.5. 父子组件的生命周期顺序</h2><ol>
<li>加载渲染过程：<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
<li>子组件更新过程：父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
<li>父组件更新过程：父beforeUpdate-&gt;父updated</li>
<li>销毁过程：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ol>
<h1 id="3-Vuex"><a href="#3-Vuex" class="headerlink" title="3. Vuex"></a>3. Vuex</h1><h2 id="3-1-vuex的核心概念"><a href="#3-1-vuex的核心概念" class="headerlink" title="3.1. vuex的核心概念"></a>3.1. vuex的核心概念</h2><ol>
<li>state =&gt; 基本数据 </li>
<li>getters =&gt; 从基本数据派生的数据 </li>
<li>mutations =&gt; 修改数据，同步 </li>
<li>actions =&gt; 修改数据，异步  (Action 提交的是 mutation，而不是直接变更状态)</li>
<li>modules =&gt; 模块化Vuex</li>
</ol>
<h2 id="3-2-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#3-2-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="3.2. vuex是什么？怎么使用？哪种功能场景使用它？"></a>3.2. vuex是什么？怎么使用？哪种功能场景使用它？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态，主要是为了多页面、多组件之间的通信。<br>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。如果你的项目很简单，最好不要使用 Vuex，对于大型项目，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。</p>
<h2 id="3-3-多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块"><a href="#3-3-多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块" class="headerlink" title="3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块"></a>3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块</h2><ol>
<li>公共的数据部分可以提升至和他们最近的父组件，由父组件派发</li>
<li>公共数据可以放到vuex中统一管理，各组件分别获取</li>
</ol>
<h1 id="4-Router"><a href="#4-Router" class="headerlink" title="4. Router"></a>4. Router</h1><h2 id="4-1-vue-router路由的两种模式"><a href="#4-1-vue-router路由的两种模式" class="headerlink" title="4.1. vue-router路由的两种模式"></a>4.1. vue-router路由的两种模式</h2><p>vue-router中默认使用的是hash模式</p>
<ol>
<li>hash模式, 带#。如：<a target="_blank" rel="noopener" href="http://localhost:8080/#/pageA%E3%80%82%E6%94%B9%E5%8F%98hash%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E8%BA%AB%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BB%BB%E4%BD%95%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E4%BD%9C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81%E5%92%8Curl%E5%B7%B2%E7%BB%8F%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E4%BA%86%E3%80%82">http://localhost:8080/#/pageA。改变hash，浏览器本身不会有任何请求服务器动作的，但是页面状态和url已经关联起来了。</a></li>
<li>history模式，不带#， 如：<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 正常的而路径，并没有#。基于HTML5的 pushState、replaceState实现</li>
</ol>
<h2 id="4-2-vue-router如何定义嵌套路由"><a href="#4-2-vue-router如何定义嵌套路由" class="headerlink" title="4.2. vue-router如何定义嵌套路由"></a>4.2. vue-router如何定义嵌套路由</h2><p>通过children 数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/parentPage&quot;</span>,</span><br><span class="line">      component: testPage,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&quot;/childrenA&quot;</span>,</span><br><span class="line">          component: childrenComponentA,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&quot;/childrenB&quot;</span>,</span><br><span class="line">          component: childrenComponentB,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 其他和parentPage平级的路由</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-3-vue-router有哪几种导航钩子？"><a href="#4-3-vue-router有哪几种导航钩子？" class="headerlink" title="4.3. vue-router有哪几种导航钩子？"></a>4.3. vue-router有哪几种导航钩子？</h2><ol>
<li>全局导航钩子：router.beforeEach(to,from,next)</li>
<li>组件内的钩子beforeRouteEnter (to, from, next) beforeRouteUpdate (to, from, next) beforeRouteLeave (to, from, next)</li>
<li>单独路由独享组件 beforeEnter: (to, from, next)</li>
</ol>
<h2 id="4-4-route和-router的区别"><a href="#4-4-route和-router的区别" class="headerlink" title="4.4. $route和$router的区别"></a>4.4. $route和$router的区别</h2><ol>
<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>
<li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>
</ol>
<h2 id="4-5-路由之间跳转的方式"><a href="#4-5-路由之间跳转的方式" class="headerlink" title="4.5. 路由之间跳转的方式"></a>4.5. 路由之间跳转的方式</h2><ol>
<li>声明式（标签跳转） </li>
<li>编程式（ js跳转）</li>
</ol>
<h2 id="4-6-active-class是哪个组件的属性"><a href="#4-6-active-class是哪个组件的属性" class="headerlink" title="4.6. active-class是哪个组件的属性"></a>4.6. active-class是哪个组件的属性</h2><p>vue-router 模块 的router-link组件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/10/React-starter-2-React-Router-Dom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/React-starter-2-React-Router-Dom/" class="post-title-link" itemprop="url">React 入门（2）- 路由 React Router</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-10 22:11:55" itemprop="dateCreated datePublished" datetime="2021-04-10T22:11:55+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-07 09:56:56" itemprop="dateModified" datetime="2021-05-07T09:56:56+08:00">2021-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#browserrouter%E4%B8%8Ehashrouter%E7%9A%84%E5%8C%BA%E5%88%AB">BrowserRouter与HashRouter的区别</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">安装和使用</a></li>
</ul>
<blockquote>
<p>环境:</p>
<ul>
<li>React 17.x</li>
<li>react-router-dom: 5.2</li>
</ul>
</blockquote>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>React 本身是一个极简的类库，并且遵循渐进式原则，所以是不带路由（Router）功能的。对于稍复杂些的应用，没有路由显然是不可以的，所以就需要引入路由（React Router）库。</p>
<p>React Router 从5.0开始只分为Core，Web 和Native3种。 从5.0开始，彻底将原本的针对网页使用的react-router的npm package命名改为了react-router-dom。也就是说，针对web应用，用react-router-dom吧。（本文暂不涉及Native)</p>
<blockquote>
<p>官方文档： <a target="_blank" rel="noopener" href="https://reacttraining.com/react-router/">https://reacttraining.com/react-router/</a></p>
</blockquote>
<h1 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h1><p>React Router 有2中模式，BrowserRouter与HashRouter，下面我们来看一下区别</p>
<ol>
<li>url表现形式不一样，看是否包含#</li>
</ol>
<ul>
<li>BrowserRouter没有，例如：<a target="_blank" rel="noopener" href="http://localhost:3000/about">http://localhost:3000/about</a></li>
<li>HashRouter的路径包含＃，例如：<a target="_blank" rel="noopener" href="http://localhost:3000/#/about">http://localhost:3000/#/about</a></li>
</ul>
<ol start="2">
<li>底层原理不一样</li>
</ol>
<ul>
<li>BrowserRouter使用的是HTML5的history API(window.history.pushState, popState)</li>
<li>HashRouter使用的是URL的哈希值。</li>
</ul>
<ol start="3">
<li>刷新后对路由state参数的影响</li>
</ol>
<ul>
<li>BrowserRouter没有任何影响，因为state保存在history对象中。</li>
<li>HashRouter刷新后会导致路由state参数的丢失。</li>
</ul>
<h1 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h1><ol>
<li><p>安装：<br><code>npm i react-router-dom</code></p>
</li>
<li><p>简单使用，<br>参考：<a target="_blank" rel="noopener" href="https://reactrouter.com/web/guides/quick-start">https://reactrouter.com/web/guides/quick-start</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/30/angular-perfromance-in-binding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/angular-perfromance-in-binding/" class="post-title-link" itemprop="url">angular绑定（脏检查）方面的性能优化技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-30 14:48:39" itemprop="dateCreated datePublished" datetime="2021-03-30T14:48:39+08:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-17 16:52:54" itemprop="dateModified" datetime="2021-04-17T16:52:54+08:00">2021-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96">1. 为什么要优化</a></li>
<li><a href="#2-%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF%E6%96%B9%E9%9D%A2">2. 编程习惯方面</a><ul>
<li><a href="#21-ngforof%E5%8A%A0%E5%85%A5trackby%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD">2.1. NgForOf，加入trackBy提升性能</a></li>
<li><a href="#22-angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">2.2. Angular数据绑定的三种方式</a></li>
<li><a href="#23-%E9%99%A4%E9%9D%9E%E9%9C%80%E8%A6%81%E9%83%BD%E6%98%AF%E7%94%A8%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A%E5%87%8F%E5%B0%91%E7%9B%91%E6%8E%A7%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0">2.3. 除非需要，都是用单向绑定，减少监控值的个数</a></li>
</ul>
</li>
<li><a href="#3-changedetectionstrategyonpush-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87">3. ChangeDetectionStrategy.OnPush 进行性能提升</a></li>
<li><a href="#4-%E5%88%A9%E7%94%A8ngzone-runoutsideangular%E4%BC%98%E5%8C%96">4. 利用ngzone-runOutsideAngular优化</a></li>
<li><a href="#5-%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E8%84%8F%E6%A3%80%E6%9F%A5-changedetectorref">5. 手动控制脏检查 ChangeDetectorRef</a></li>
<li><a href="#6-%E6%80%BB%E7%BB%93">6. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular: 8+</li>
</ul>
</blockquote>
<h1 id="1-为什么要优化"><a href="#1-为什么要优化" class="headerlink" title="1. 为什么要优化"></a>1. 为什么要优化</h1><p>双向绑定是一柄双刃剑，提高开发效率的同时，也牺牲了性能。当然，随着硬件性能的提升，Angular自身性能的提升，对于一般（中小）复杂度的应用，性能问题可以忽略不计。但是对于特殊场景，或复杂页面来说，我们就需要单独的处理数据绑定问题，否则就会有卡顿的现象，影响用户体验。</p>
<h1 id="2-编程习惯方面"><a href="#2-编程习惯方面" class="headerlink" title="2. 编程习惯方面"></a>2. 编程习惯方面</h1><p>平时的一些小技巧，小习惯，都可以改善Angular绑定方面的性能。</p>
<h2 id="2-1-NgForOf，加入trackBy提升性能"><a href="#2-1-NgForOf，加入trackBy提升性能" class="headerlink" title="2.1. NgForOf，加入trackBy提升性能"></a>2.1. NgForOf，加入trackBy提升性能</h2><p>trackBy定义如何跟踪可迭代项的更改的函数。在迭代器中添加、移动或删除条目时，指令必须重新渲染适当的 DOM 节点。为了最大程度地减少 DOM 中的搅动，仅重新渲染已更改的节点。</p>
<p>默认情况下，变更检测器假定对象实例标识可迭代对象。提供此函数后，指令将使用调用此函数的结果来标识项节点，而不是对象本身的标识。</p>
<h2 id="2-2-Angular数据绑定的三种方式"><a href="#2-2-Angular数据绑定的三种方式" class="headerlink" title="2.2. Angular数据绑定的三种方式"></a>2.2. Angular数据绑定的三种方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Name &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 1. 直接绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Classes &#123;&#123;item | classPipe&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- 2. pipe方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Classes &#123;&#123;classes(item)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- 3.绑定方法调用的结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>直接绑定： 大多数情况下，这都是性能最好的方式。</li>
<li>绑定方法调用的结果：在每个脏值检测过程中，classes方程都要被调用一遍。如果没有特殊需求，应尽量避免这种使用方式。</li>
<li>pipe方式： 它和绑定function类似，每次脏值检测classPipe都会被调用。不过Angular给pipe做了优化，加了缓存，如果item和上次相等，则直接返回结果。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let item of items; index as i; trackBy: trackByFn&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-除非需要，都是用单向绑定，减少监控值的个数"><a href="#2-3-除非需要，都是用单向绑定，减少监控值的个数" class="headerlink" title="2.3. 除非需要，都是用单向绑定，减少监控值的个数"></a>2.3. 除非需要，都是用单向绑定，减少监控值的个数</h2><p>对于一般数据来说，都是只需要展示给用户，不需要修改。那么对于这部分数据，使用单向绑定即可(ts-&gt;html).<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 也称插值绑定 --&gt;</span><br><span class="line"> &lt;span&gt;&#123;&#123;yourMessage&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<h1 id="3-ChangeDetectionStrategy-OnPush-进行性能提升"><a href="#3-ChangeDetectionStrategy-OnPush-进行性能提升" class="headerlink" title="3. ChangeDetectionStrategy.OnPush 进行性能提升"></a>3. ChangeDetectionStrategy.OnPush 进行性能提升</h1><p>对于一些很复杂的页面，上面的小技巧就不够用了，不过Angular也是考虑到这些了，提供了不少方法。<br>Angular 对比 AngularJS 在变化检测上由原来的双向检测(父-&gt;子，子-&gt;父)变为了单向(父-&gt;子)。所以每一次变化检测都会确定性地收敛。<br>Angular定义一个组件时，可以传入一个变化检测配置项为</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeDetection: ChangeDetectionStrategy.OnPush | ChangeDetectionStrategy.Default;</span><br></pre></td></tr></table></figure>

<p>onpush策略只判断输入的引用(如果是object)是否改变，来判断是否进行脏检查。因此，我们可以使用onpush策略来减少变化检测的开销。</p>
<h1 id="4-利用ngzone-runOutsideAngular优化"><a href="#4-利用ngzone-runOutsideAngular优化" class="headerlink" title="4. 利用ngzone-runOutsideAngular优化"></a>4. 利用ngzone-runOutsideAngular优化</h1><p>Angular依赖NgZone来监听异步操作，并从根部执行变化检测。换句话说，我们代码中的每一个 addEventListener都会触发脏检查。但是如果我们非常明确，有些addEventListener要执行的东西，不会（或者说可以忽略）影响数据结果，不想然他触发脏检查。比如监测scroll，监测鼠标事件等。</p>
<p>针对这种情况， 我们可以使用zone提供的runOutsideAngular，让这些事件不触发脏检查。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.zone.runOutsideAngular(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.document.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.bindMouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="5-手动控制脏检查-ChangeDetectorRef"><a href="#5-手动控制脏检查-ChangeDetectorRef" class="headerlink" title="5. 手动控制脏检查 ChangeDetectorRef"></a>5. 手动控制脏检查 ChangeDetectorRef</h1><p>Angular的ChangeDetectorRef实例上提供了可以绑定或解绑某个组件脏检查的方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeDetectorRef</span> </span>&#123;</span><br><span class="line">  markForCheck() : <span class="built_in">void</span>     <span class="comment">// 通知框架进行变化检查/Change Detection</span></span><br><span class="line">  detach() : <span class="built_in">void</span>           <span class="comment">// 禁止脏检查</span></span><br><span class="line">  detectChanges() : <span class="built_in">void</span>    <span class="comment">// 手工触发脏检查， 从该组件到各个子组件执行一次变化检测</span></span><br><span class="line">  checkNoChanges() : <span class="built_in">void</span></span><br><span class="line">  reattach() : <span class="built_in">void</span>         <span class="comment">// detach逆操作，启用脏检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ol>
<li>平时的一些小习惯，都可以提高angular的性能；</li>
<li>针对复杂应用，或者当出现卡顿时，我们也是有办法的！</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/07/CSS-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/CSS-interview-qa/" class="post-title-link" itemprop="url">CSS面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-07 13:06:00" itemprop="dateCreated datePublished" datetime="2021-03-07T13:06:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-09 16:43:47" itemprop="dateModified" datetime="2021-03-09T16:43:47+08:00">2021-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSS实现水平垂直居中"><a href="#CSS实现水平垂直居中" class="headerlink" title="CSS实现水平垂直居中"></a>CSS实现水平垂直居中</h1><ol>
<li>margin: auto;实现绝对定位元素的居中</li>
</ol>
<pre><code class="css">    .center-vertical&#123;
        width: 100px;
        height: 100px;
        background: orange;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
    &#125;
</code></pre>
<ol start="2">
<li>CSS3.0弹性布局<pre><code class="css">   html,
   body &#123;
     width: 100%;
     height: 100%;
   &#125;
   body &#123;
     display: flex;
     align-items: center;
     justify-content: center; /* 定义body的元素水平居中 */
   &#125;
   .content &#123;
     width: 300px;
     height: 300px;
     background: orange;
   &#125;
</code></pre>
</li>
</ol>
<h1 id="行内元素有哪些？块级元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？"></a>行内元素有哪些？块级元素有哪些？</h1><ol>
<li>行内元素有：<code>a b span img input select strong</code></li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li>
<li>常见的空元素：    <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ol>
<h1 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h1><ol>
<li>新增各种CSS选择器  （: not(.input)：）</li>
<li>圆角            （border-radius:8px）</li>
<li>多列布局      （multi-column layout）</li>
<li>阴影和反射   （Shadow\Reflect）</li>
<li>文字特效      （text-shadow）</li>
<li>文字渲染      （Text-decoration）</li>
<li>线性渐变      （gradient）</li>
<li>旋转            （transform）</li>
<li>缩放,定位,倾斜,动画,多背景</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/07/web-frontend-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/web-frontend-interview-qa/" class="post-title-link" itemprop="url">前端(Fontend)面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-07 13:06:00" itemprop="dateCreated datePublished" datetime="2021-03-07T13:06:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 01:01:04" itemprop="dateModified" datetime="2021-04-23T01:01:04+08:00">2021-04-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a href="https://jackniu81.github.io/2021/03/07/web-frontend-interview-qa/">前端(Fontend)面试题汇总</a></p>
</blockquote>
<h1 id="1-http-1-1-2-0-新增加的功能"><a href="#1-http-1-1-2-0-新增加的功能" class="headerlink" title="1. http 1.1/2.0 新增加的功能"></a>1. http 1.1/2.0 新增加的功能</h1><p><strong>HTTP1.1</strong></p>
<ol>
<li><strong>缓存处理</strong>，在 HTTP1.0 中主要使用 header 来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 并且支持断点续传。</li>
<li><strong>错误通知的管理</strong>，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>
<li>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应. (Connection： keep-alive)</li>
</ol>
<p><strong>HTTP2.0</strong> 大幅度的提高了 web 性能，进一步减少了网络的延迟。实现低延迟高吞吐量。</p>
<ol>
<li>二进制分帧 （二进制格式编码）</li>
<li>首部压缩 （header）</li>
<li>多路复用 （HTTP2.0 可以在共享 TCP 连接的基础上同时发送请求和响应，避免 HTTP 旧版本的队头阻塞问题）</li>
<li>请求优先级</li>
<li>服务器推送 （服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。）</li>
</ol>
<h1 id="2-用户输入-URL-到浏览器显现给用户页面经过了什么过程"><a href="#2-用户输入-URL-到浏览器显现给用户页面经过了什么过程" class="headerlink" title="2. 用户输入 URL 到浏览器显现给用户页面经过了什么过程"></a>2. 用户输入 URL 到浏览器显现给用户页面经过了什么过程</h1><ol>
<li>用户输入 URL，浏览器获取到 URL</li>
<li>检查缓存，如果有有效缓存，直接加载</li>
<li>浏览器(应用层)进行 DNS 解析（直接输入 IP 地址既跳过该步骤）</li>
<li>根据解析出的 IP 地址+端口，浏览器（应用层）发起 HTTP 请求</li>
<li>请求到达传输层，tcp 协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。</li>
<li>服务器端收到发送方的 HTTP 请求之后，进行请求文件资源（如 HTML 页面）的寻找并响应报文</li>
<li>客户端收到返回内容后，处理 html</li>
<li>解析 html，生成 dom 树</li>
<li>CSS 解析，为 DOM 中元素加入样式</li>
<li>javascript 解析处理，更改 dom 树</li>
<li>进行页面渲染</li>
<li>重排、重绘</li>
</ol>
<h1 id="3-HTML5-的新特性"><a href="#3-HTML5-的新特性" class="headerlink" title="3. HTML5 的新特性"></a>3. HTML5 的新特性</h1><ol>
<li>新的内容标签：header nav content footer article 1. aside</li>
<li>更好的单元格体系:</li>
<li>音频、视频 API:video radio</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>网页存储(Web storage) 1. API:localStorage,sessionStorage</li>
<li>拖拽释放(Drag and drop) API</li>
</ol>
<h1 id="4-对浏览器内核的理解"><a href="#4-对浏览器内核的理解" class="headerlink" title="4. 对浏览器内核的理解"></a>4. 对浏览器内核的理解</h1><p>主要分成两部分：渲染引擎(layout engine 或 Rendering Engine)和 JS 引擎。</p>
<ol>
<li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li>
<li>JS 引擎则：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li>
</ol>
<h1 id="5-cookies，sessionStorage-和-localStorage"><a href="#5-cookies，sessionStorage-和-localStorage" class="headerlink" title="5. cookies，sessionStorage 和 localStorage"></a>5. cookies，sessionStorage 和 localStorage</h1><p>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</p>
<p>存储大小：<br>cookie 数据大小不能超过 4k。<br>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</p>
<p>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h1 id="6-如何实现浏览器内多个标签页之间的通"><a href="#6-如何实现浏览器内多个标签页之间的通" class="headerlink" title="6. 如何实现浏览器内多个标签页之间的通"></a>6. 如何实现浏览器内多个标签页之间的通</h1><p>WebSocket、SharedWorker；也可以调用 localstorge、cookies 等本地存储方式；</p>
<h1 id="7-script标签中的async、defer属性的作用"><a href="#7-script标签中的async、defer属性的作用" class="headerlink" title="7. script标签中的async、defer属性的作用"></a>7. script标签中的async、defer属性的作用</h1><ol>
<li>Async: 可选属性。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。</li>
<li>Defer: 可选属性。标识脚本可以延迟到文档完全被解析和显示之后再执行。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/02/javascript-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/javascript-interview-qa/" class="post-title-link" itemprop="url">2021 javascript 面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-02 14:06:00" itemprop="dateCreated datePublished" datetime="2021-03-02T14:06:00+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-27 01:01:04" itemprop="dateModified" datetime="2021-04-27T01:01:04+08:00">2021-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a href="https://jackniu81.github.io/2021/03/02/javascript-interview-qa/">2021 javascript 面试题汇总</a></p>
</blockquote>
<h1 id="1-this-都可以是哪些内容"><a href="#1-this-都可以是哪些内容" class="headerlink" title="1. this 都可以是哪些内容"></a>1. this 都可以是哪些内容</h1><p>对 C#、Java 等语言，this 就是当前对象，但是 javascript 不是，简单来说：</p>
<ul>
<li>全局 this 是 window;</li>
<li>函数 this 是调用者;</li>
<li>构造函数的 this 是 new 之后的新对象,</li>
<li>call 和 apply bind 的 this 第一个参数</li>
</ul>
<h1 id="2-原型链-prototype"><a href="#2-原型链-prototype" class="headerlink" title="2. 原型链, prototype"></a>2. 原型链, prototype</h1><ul>
<li>函数对象都包含 prototype 属性（函数的原型对象），其作用就是让该函数所实例化的对象们都可以找到公用的属性和方法；</li>
<li>constructor 属性的含义就是指向该对象的构造函数</li>
<li><code>__proto__</code>和 constructor 属性是对象所独有的；prototype 属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和 constructor 属性。</li>
<li>JavaScript 的每个对象都继承另一个父级对象，父级对象称为原型 (prototype) 对象。</li>
<li>每一个实例对象都有一个私有属性<strong>proto</strong>指向其构造函数的原型对象 prototype；该原型对象也会作为实例对象有一个私有属性<strong>proto</strong>，层层向上直到一个对象的原型对象值为 null。</li>
<li>当访问一个对象的属性或方法时，js 引擎会先查找该对象本身是否包含，如果没有，会去该对象的<strong>proto</strong>属性所指向的原型对象上找，如果没有，会继续向上一层找，直到某个对象的<strong>proto</strong>值为 null,这就是原型链。</li>
<li>每个构造函数都有一个 prototype 属性，指向另外一个对象，说明整个对象所有的属性和方法都会被构造函数所拥有。</li>
</ul>
<h1 id="3-new-操作符都做了什么"><a href="#3-new-操作符都做了什么" class="headerlink" title="3. new 操作符都做了什么"></a>3. new 操作符都做了什么</h1><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p>
<p>new Object()举例:</p>
<ol>
<li>创建一个新对象</li>
<li>把新对象的原型(<code>__proto__</code>)指向构造函数的 prototype</li>
<li>把构造函数里的 this 指向新对象</li>
<li>返回这个新对象</li>
</ol>
<h1 id="4-Javascript-的内存回收机制"><a href="#4-Javascript-的内存回收机制" class="headerlink" title="4. Javascript 的内存回收机制"></a>4. Javascript 的内存回收机制</h1><p>Javascript 内嵌了垃圾收集器，用来跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。垃圾收集器会按照固定的时间间隔，或代码执行中预定的收集时间，周期性地执行这一操作。<br>垃圾收集器必须跟踪哪个变量有用哪个变量无用，对于不再有用的变量打上标记，以备将来收回其所占用的内存。用于标识无用变量的策略通常有标记清除和引用计数两种。不同浏览器采用的策略不完全一致。</p>
<h1 id="5-内存泄漏的主要原因"><a href="#5-内存泄漏的主要原因" class="headerlink" title="5. 内存泄漏的主要原因"></a>5. 内存泄漏的主要原因</h1><ul>
<li>缓存</li>
<li>队列消费不及时</li>
<li>作用域未释放</li>
</ul>
<h1 id="6-Javascript-性能优化"><a href="#6-Javascript-性能优化" class="headerlink" title="6. Javascript 性能优化"></a>6. Javascript 性能优化</h1><ol>
<li>针对 js 方面的前端性能优化，可以 1）使用 ansyc/defer 加载；2）加载时，放到<code>&lt;/body&gt;</code>之前；3) 合并 JS 文件，并进行最小化处理；4）缓存；5）使用 CDN 网络；6）js 的 HTTP 压缩</li>
<li>删除未使用的功能性代码以及与之相关的代码， 多余的依赖库，被滥用的 npm 包。</li>
<li>减少作用域链上的查找次数（减少循环中的活动）。比如 for 循环，把 Array.length 赋值给一个变量，而不是每次比较都直接使用 length 属性；对页面元素进行操作时，取出复制给一个变量，每次操作都对这个变量进行操作，而不是每次操作都再重复取一下这个元素；</li>
<li>闭包导致的内存泄露。闭包可以保证函数内的变量安全，可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会被自动清除。我们需要手动销毁内存中的变量。（赋值为 null）；</li>
<li>尽量少用全局变量，尽量使用局部变量。</li>
<li>减少不必要的变量</li>
<li>类型转换：把数字转换成字符串使用 number + “” 。 性能对比： (“” + ) &gt; String() &gt; .toString() &gt; new String()</li>
<li>对字符串进行循环操作，譬如替换、查找，应使用正则表达式。因为本身 JavaScript 的循环速度就比较慢，而正则表达式的操作是用 C 写成的语言的 API，性能很好。</li>
<li>浮点数转换成整型使用 Math.floor()或者 Math.round()。parseInt()是用于将字符串转换成数字，Math 是内部对象，所以 Math.floor()其实并没有多少查询方法和调用的时间，速度是最快的。</li>
<li>使用 classname 代替大量的内联样式修改。</li>
<li>循环遍历，尽量少用 for in， 虽然代码易读，但性能很差。 尤其是遍历属性数量未知的情况下，少用。</li>
</ol>
<h1 id="7-ES6-ES7-ES8-…-新增的功能"><a href="#7-ES6-ES7-ES8-…-新增的功能" class="headerlink" title="7. ES6/ES7/ES8/… 新增的功能"></a>7. ES6/ES7/ES8/… 新增的功能</h1><h2 id="7-1-ES6-（2015）"><a href="#7-1-ES6-（2015）" class="headerlink" title="7.1. ES6 （2015）"></a>7.1. ES6 （2015）</h2><ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let与Const</li>
</ul>
<h2 id="7-2-ES7（2016）"><a href="#7-2-ES7（2016）" class="headerlink" title="7.2. ES7（2016）"></a>7.2. ES7（2016）</h2><ul>
<li>数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</li>
<li>**指数运算符： a ** b指数运算符，它与 Math.pow(a, b)相同。<h2 id="7-3-ES8（2017）"><a href="#7-3-ES8（2017）" class="headerlink" title="7.3. ES8（2017）"></a>7.3. ES8（2017）</h2></li>
<li>async/await</li>
<li>Object.values()</li>
<li>Object.entries()</li>
<li>String padding: padStart()和padEnd()，填充字符串达到当前长度</li>
<li>函数参数列表结尾允许逗号</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>ShareArrayBuffer和Atomics对象，用于从共享内存位置读取和写入<h2 id="7-4-ES9（2018）"><a href="#7-4-ES9（2018）" class="headerlink" title="7.4. ES9（2018）"></a>7.4. ES9（2018）</h2></li>
<li>异步迭代</li>
<li>Promise.finally()</li>
<li>Rest/Spread 属性: ES2015引入了Rest参数和扩展运算符。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。</li>
<li>正则表达式命名捕获组</li>
<li>正则表达式反向断言</li>
</ul>
<h2 id="7-5-ES10新特性（2019）"><a href="#7-5-ES10新特性（2019）" class="headerlink" title="7.5. ES10新特性（2019）"></a>7.5. ES10新特性（2019）</h2><ul>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</li>
<li>更加友好的 JSON.stringify</li>
<li>新增了Array的flat()方法和flatMap()方法</li>
<li>新增了String的trimStart()方法和trimEnd()方法</li>
<li>Object.fromEntries()</li>
<li>Symbol.prototype.description</li>
<li>String.prototype.matchAll</li>
<li>Function.prototype.toString()现在返回精确字符，包括空格和注释</li>
<li>简化try {} catch {},修改 catch 绑定</li>
<li>新的基本数据类型BigInt</li>
<li>globalThis</li>
<li>import()</li>
<li>Legacy RegEx</li>
<li>私有的实例方法和访问器</li>
</ul>
<h2 id="7-6-ES11（2020）"><a href="#7-6-ES11（2020）" class="headerlink" title="7.6. ES11（2020）"></a>7.6. ES11（2020）</h2><ul>
<li>Nullish coalescing Operator(空值处理)</li>
<li>import() 按需导入</li>
</ul>
<h2 id="7-7-ES12（2021）"><a href="#7-7-ES12（2021）" class="headerlink" title="7.7. ES12（2021）"></a>7.7. ES12（2021）</h2><ul>
<li>string增加replaceAll</li>
<li>Promise.any, 收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise</li>
<li>WeakRefs, 使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</li>
<li>数字分隔符</li>
<li>逻辑运算符和赋值表达式</li>
</ul>
<h1 id="8-VS"><a href="#8-VS" class="headerlink" title="8. === VS =="></a>8. === VS ==</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">&quot;100&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&quot;&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&quot;&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>很有意思吧， 看看这两个，是等效的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj == <span class="literal">null</span>;</span><br><span class="line">obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h1 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h1><p>在 JavaScript 中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure)。这得益于高阶函数的特性：函数可以作为参数或者者返回值；</p>
<p><strong>当一个内部函数被调用，就会形成闭包</strong>，闭包就是能够读取其他函数内部变量的函数，就是一个函数去访问了另外一个函数的中的变量的函数。</p>
<p><strong>闭包作用</strong>：局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。延伸变量的作用范围。</p>
<p><strong>闭包特点</strong>：占用更多内存；不容易被释放</p>
<p><strong>闭包用法</strong>：变量既想反复使用，又想避免全局污染如何使用？</p>
<ol>
<li>定义外层函数，封装被保护的局部变量。</li>
<li>定义内层函数，执行对外部函数变量的操作。</li>
<li>外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。</li>
</ol>
<p>e.g.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> innerMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  innerMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-js-里的作用域是什么样子的？"><a href="#10-js-里的作用域是什么样子的？" class="headerlink" title="10. js 里的作用域是什么样子的？"></a>10. js 里的作用域是什么样子的？</h1><p>大多数语言里边都是块作作用域，以{}进行限定，js 里边不是．js 里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量 p1 在函数最后一行定义，第一行也有效，但是值是 undefined.</p>
<h1 id="11-let-和-var-的区别"><a href="#11-let-和-var-的区别" class="headerlink" title="11. let 和 var 的区别"></a>11. let 和 var 的区别</h1><ul>
<li>var 声明变量可以重复声明，而 let 不可以重复声明，属于 TDZ 暂时性死区问题</li>
<li>作用域不同，var 是函数作用域，而 let 是块级作用域；</li>
<li>var 可以在声明的上面访问变量，而 let 不存在变量提升；</li>
</ul>
<h1 id="12-对-async-和-await-的理解"><a href="#12-对-async-和-await-的理解" class="headerlink" title="12. 对 async 和 await 的理解"></a>12. 对 async 和 await 的理解</h1><ol>
<li>async…await 是基于 promise 的 generator 语法糖，是用来解决异步的，它用来等待 promise 的执行结果，常规函数使用 await 没有效果；</li>
<li>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</li>
<li>当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句；</li>
</ol>
<h1 id="13-promised-的三种状态"><a href="#13-promised-的三种状态" class="headerlink" title="13. promised 的三种状态"></a>13. promised 的三种状态</h1><p>promise 有三种状态：pending/reslove/reject 。pending 就是未决，resolve 可以理解为成功，reject 可以理解为拒绝。</p>
<h1 id="14-async-await-的优点"><a href="#14-async-await-的优点" class="headerlink" title="14. async/await 的优点"></a>14. async/await 的优点</h1><p><strong>1）方便级联调用：</strong> 即调用依次发生的场景；</p>
<p><strong>2）同步代码编写方式：</strong> Promise 使用 then 函数进行链式调用，一直点点点，是一种从左向右的横向写法；async/await 从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯；</p>
<p><strong>3）多个参数传递：</strong> Promise 的 then 函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦；async/await 没有这个限制，可以当做普通的局部变量来处理，用 let 或者 const 定义的块级变量想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余工作；</p>
<p><strong>4）同步代码和异步代码可以一起编写：</strong> 使用 Promise 的时候最好将同步代码和异步代码放在不同的 then 节点中，这样结构更加清晰；async/await 整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个 Promise 对象放在 await 关键字后面；</p>
<p><strong>5）基于协程：</strong> Promise 是根据函数式编程的范式，对异步过程进行了一层封装，async/await 基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</p>
<p><strong>6）async/await 是对 Promise 的优化：</strong> async/await 是基于 Promise 的，是进一步的一种优化，不过在写代码时，Promise 本身的 API 出现得很少，很接近同步代码的写法；</p>
<h1 id="15-async-await-的写法"><a href="#15-async-await-的写法" class="headerlink" title="15. async/await 的写法"></a>15. async/await 的写法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-apply、call-和-bind-的区别"><a href="#16-apply、call-和-bind-的区别" class="headerlink" title="16. apply、call 和 bind 的区别"></a>16. apply、call 和 bind 的区别</h1><p>这三者都是用来改变函数的 this 对象的指向的(也就是说要改变函数运行时的 context 即上下文),第一个参数都是 this 要指向的对象。</p>
<p>不同之处：</p>
<ol>
<li>call 接受连续参数，apply 接受数组参数。</li>
<li>bind 功能和 call apply 差不多，区别在于 bind 返回的是一个改变 this 指向的新函数，这个函数不是立即执行函数（call apply 两个立即执行！）</li>
</ol>
<h1 id="17-深拷贝的原理"><a href="#17-深拷贝的原理" class="headerlink" title="17. 深拷贝的原理"></a>17. 深拷贝的原理</h1><p>操作的是值，取出对象的值，放到一个新的{}，修改时不会影响到原数据；要完成对象的深拷贝需要使用递归遍历所有对象的属性进行赋值，也可以使用 JSON.stringfy 和 JSON.parse 操作。</p>
<h1 id="18-set-和-Map-的区别"><a href="#18-set-和-Map-的区别" class="headerlink" title="18. set 和 Map 的区别"></a>18. set 和 Map 的区别</h1><ol>
<li>Set 是一种类似数组的集合类型，它与数组不同的是，不允许存在重复数据；常用操作方法有：add,delete,has,clear 等；遍历使用 forEach；</li>
<li>Map 是一种类似对象的集合类型，它与对象不同的是，key 可以接受对象类型，常用的操作方法有：set,get,has,delete 等；遍历使用 forEach</li>
</ol>
<h1 id="19-JS-实现双向绑定-（vue-angular-双向绑定的原理）"><a href="#19-JS-实现双向绑定-（vue-angular-双向绑定的原理）" class="headerlink" title="19. JS 实现双向绑定 （vue/angular 双向绑定的原理）"></a>19. JS 实现双向绑定 （vue/angular 双向绑定的原理）</h1><p><strong>vue.js</strong> 采用数据劫持（Proxy 模式）结合发布者-订阅者模式（PubSub 模式）的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>Object.defineProperty( )内还包含一对儿 getter 和 setter 函数，它们被称作这个对象的访问器属性，这两个函数都不是必须的，只是在读取访问对象属性时，会调用 getter 函数，这个函数负责返回有效值，在写入对象属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。</p>
<p><strong>Angular</strong>, 采用脏检查的方式。基于 zone.js，重写 setTimeout, httpRequest 等方法，触发脏检查, 更新 dom 节点。</p>
<h1 id="20-var-和-let-的区别"><a href="#20-var-和-let-的区别" class="headerlink" title="20. var 和 let 的区别"></a>20. var 和 let 的区别</h1><ol>
<li>作用域不同， var 是函数作用域，let 是块作用域。</li>
</ol>
<ul>
<li>在函数中声明了 var，整个函数内都是有效的，比如说在 for 循环内定义的一个 var 变量，实际上其在 for 循环以外也是可以访问的</li>
<li>而 let 由于是块作用域，所以如果在块作用域内定义的变量，比如说在 for 循环内，在其外面是不可被访问的，所以 for 循环推荐用 let</li>
</ul>
<ol start="2">
<li>let 不能在定义之前访问该变量，但是 var 可以。 （var 可以提升变量作用域）</li>
<li>let不能被重新定义，但是var是可以的。（重新定义var，执行时会忽略）<h1 id="21-Javascript-如何实现继承？"><a href="#21-Javascript-如何实现继承？" class="headerlink" title="21. Javascript 如何实现继承？"></a>21. Javascript 如何实现继承？</h1></li>
</ol>
<p>1、构造继承<br>2、原型继承: Child.prototype = new Parent();<br>3、实例继承<br>4、拷贝继承</p>
<h1 id="22-变量提升"><a href="#22-变量提升" class="headerlink" title="22. 变量提升"></a>22. 变量提升</h1><p>js 引擎首先在读取 js 代码时默认执行 2 个步骤：</p>
<ol>
<li>解释(通篇扫描所有 js 代码，然后把所有声明(变量申明、函数声明)提升到对应作用域顶端)</li>
<li>执行(执行逻辑操作)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 ReferenceError: b is not defined</span></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<h1 id="23-函数提升"><a href="#23-函数提升" class="headerlink" title="23. 函数提升"></a>23. 函数提升</h1><p>首先要知道函数定义有两种方式的，一种是函数定义表达式，一种是函数声明语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提升测试</span></span><br><span class="line"><span class="comment">// 例1.</span></span><br><span class="line">f();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2.</span></span><br><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 Uncaught TypeError: f is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="comment">//  [Function: f]</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例4</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 输出：10</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 看似无用， 实际上在foo的作用域内重新声明了&#x27;a&#x27;，和外面的a不一样了</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：1</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>重点：</p>
<ol>
<li>函数提升针对是函数声明语句而言，其次变量提升只提升变量名而函数提升会提升整个函数体</li>
<li>优先级，函数提升会在变量提升的上面</li>
</ol>
<h1 id="24-作用域"><a href="#24-作用域" class="headerlink" title="24. 作用域"></a>24. 作用域</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1 块级作用域, 不适合变量提升</span></span><br><span class="line"><span class="comment">// es6允许块级作用域的任意嵌套。外层作用域无法读取内层作用域的变量。</span></span><br><span class="line"><span class="comment">// 内层作用域可以定义外层作用域的同名变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> z = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(v, z);</span><br><span class="line"><span class="comment">//输出 :</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2 闭包，变量提升</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//输出 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例 3， 块级作用域内let和const命令所声明的变量，只在命令所在的代码块内有效。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例4 let， var与作用域、变量提升</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="25-实现一个随机排序的程序"><a href="#25-实现一个随机排序的程序" class="headerlink" title="25. 实现一个随机排序的程序"></a>25. 实现一个随机排序的程序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">list.sort(randomSort);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after random sort: &quot;</span>, list.join(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">list.sort(<span class="function">() =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after random sort: &quot;</span>, list.join(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="26-实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量"><a href="#26-实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量" class="headerlink" title="26. 实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量"></a>26. 实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMostUsedChar</span>(<span class="params">sourceString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = sourceString.length;</span><br><span class="line">  <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentChar = sourceString[i];</span><br><span class="line">    <span class="keyword">if</span> (counter[currentChar]) &#123;</span><br><span class="line">      counter[currentChar]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      counter[currentChar] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> maxCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxChar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter[key] &gt;= maxCount) &#123;</span><br><span class="line">      maxChar = key;</span><br><span class="line">      maxCount = counter[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`most used char: <span class="subst">$&#123;maxChar&#125;</span>, count: <span class="subst">$&#123;maxCount&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMostUsedChar(<span class="string">&quot;fjiwejfal33232jkj3fjfie&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md">https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jack</p>
  <div class="site-description" itemprop="description">Full stack engineer, focus on: Angular/React, node.js/.Net</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
