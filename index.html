<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jackniu81.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Full stack engineer, focus on: Angular&#x2F;React, node.js&#x2F;.Net">
<meta property="og:type" content="website">
<meta property="og:title" content="Jack N @ GitHub">
<meta property="og:url" content="https://jackniu81.github.io/index.html">
<meta property="og:site_name" content="Jack N @ GitHub">
<meta property="og:description" content="Full stack engineer, focus on: Angular&#x2F;React, node.js&#x2F;.Net">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="Angular, React, node.js, .Net, C#">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jackniu81.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jack N @ GitHub</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jack N @ GitHub</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Full stack engineer, focus on: Angular/React, node.js/.Net</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/18/Algorithm-Fibonacci-numbers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/Algorithm-Fibonacci-numbers/" class="post-title-link" itemprop="url">\[算法\] - 不使用递归，实现斐波那契数列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 15:23:09" itemprop="dateCreated datePublished" datetime="2021-04-18T15:23:09+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 14:06:36" itemprop="dateModified" datetime="2021-04-19T14:06:36+08:00">2021-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h1><p><code>斐波那契数列</code>：0, 1, 1,  2,  3, 5, 8, 13 … …  </p>
<p>通常用 F(n) 表示，形成的序列称为 <code>斐波那契数列</code> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>，F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>敏捷开发时，我们估算<code>Story Point</code>，通常就是使用斐波那契数列。</p>
<h1 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1. 递归"></a>2.1. 递归</h2><p>F(n) = F(n - 1) + F(n - 2)， 很简单，就不谈了。</p>
<h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2. 动态规划"></a>2.2. 动态规划</h2><p>动态规划的思想是，记录中间计算结果，计算后面相时，根据前面保存的结果直接计算，避免重复计算。</p>
<h2 id="2-3-Javascript-实现"><a href="#2-3-Javascript-实现" class="headerlink" title="2.3. Javascript 实现"></a>2.3. Javascript 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        arr[i] = arr[i-<span class="number">1</span>] + arr[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/16/dotnet-core-interview-questions-and-answers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/dotnet-core-interview-questions-and-answers/" class="post-title-link" itemprop="url">2021 .NET/dotnet Core/C# 面试题及参考答案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-16 14:49:34" itemprop="dateCreated datePublished" datetime="2021-04-16T14:49:34+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-18 15:06:30" itemprop="dateModified" datetime="2021-04-18T15:06:30+08:00">2021-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-NET-dotnet-core-NET-framework-的关系"><a href="#1-NET-dotnet-core-NET-framework-的关系" class="headerlink" title="1. NET/dotnet core/.NET framework 的关系?"></a>1. NET/dotnet core/.NET framework 的关系?</h1><p>先看 2 张图<br>最新的.NET 5 的示意图<br><img src="https://img-blog.csdnimg.cn/20210415135448910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4ODcxNA==,size_16,color_FFFFFF,t_70#pic_center" alt=".NET 5"><br>之前的（dotnet core3.x 时代）的示意图<br><img src="https://img-blog.csdnimg.cn/20210415135513293.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI4ODcxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="dotnet core .3.1 "><br>总结如下：</p>
<ol>
<li>2016 年开始，分开了.NET Framework 和.NET Core，后者开源、面向跨平台应用；</li>
<li>2019 年，.NET Framework 和.NET Core 被.NET5 完成了统一。未来只会有一个.NET，可以支持 Windows、Linux、macOS、iOS、Android、tvOS、watchOS 和 WebAssembly，等等</li>
<li>.Net standard library 是之前.NET Framework 和.NET Core 公共的部分；</li>
</ol>
<h1 id="2-corefx-coreclr-都是什么？"><a href="#2-corefx-coreclr-都是什么？" class="headerlink" title="2. corefx, coreclr 都是什么？"></a>2. corefx, coreclr 都是什么？</h1><p>dotnet 组织包含了.NET Core 的核心代码, 包括 coreclr 和 corefx 等.</p>
<ol>
<li>coreclr 是运行时代码,</li>
<li>corefx 是各种基础类库的代码. CoreFX 主要包含数个公共库，例如 System.Collections, System.IO, System.Xml 等。</li>
</ol>
<h1 id="3-asp-net-core"><a href="#3-asp-net-core" class="headerlink" title="3. asp.net core"></a>3. asp.net core</h1><h2 id="3-1-Kestrel"><a href="#3-1-Kestrel" class="headerlink" title="3.1. Kestrel"></a>3.1. Kestrel</h2><p>Kestrel 是 asp.net core 引入的跨平台的网络服务器，是默认配置。可以没有 iis, apache 和 nginx 就可以单独运行。<br>Kestrel 基于 libuv 实现；（node.js 也是基于 libuv）</p>
<h2 id="3-2-asp-net-core-主要的特性"><a href="#3-2-asp-net-core-主要的特性" class="headerlink" title="3.2. asp.net core 主要的特性"></a>3.2. asp.net core 主要的特性</h2><ol>
<li>依赖注入。</li>
<li>日志系统架构。</li>
<li>引入了一个跨平台的网络服务器，kestrel。可以没有 iis, apache 和 nginx 就可以单独运行。</li>
<li>可以使用命令行创建应用。</li>
<li>使用 AppSettings.json 来配置工程。</li>
<li>使用 start up 来注册服务。</li>
<li>更好的支持异步编程。</li>
<li>支持 web socket 和 signal IR。</li>
<li>对于跨网站的请求的预防和保护机制。</li>
</ol>
<h2 id="3-3-startup-class-的作用？"><a href="#3-3-startup-class-的作用？" class="headerlink" title="3.3. startup class 的作用？"></a>3.3. startup class 的作用？</h2><p>Startup class 是 dot net core 应用的入口。所有的 dot net core 应用必须有这个 class。这个类用来配置应用。这个类的调用是在 program main 函数里面进行配置的。类的名字可以自己定义。</p>
<h2 id="3-4-Startup-class-的-config-service-方法有什么作用"><a href="#3-4-Startup-class-的-config-service-方法有什么作用" class="headerlink" title="3.4. Startup class 的 config service 方法有什么作用?"></a>3.4. Startup class 的 config service 方法有什么作用?</h2><p>在这个方法里我们可以添加一些 service 进入依赖注入容器。</p>
<h2 id="3-5-startup-class-的-configure-方法有什么作用？"><a href="#3-5-startup-class-的-configure-方法有什么作用？" class="headerlink" title="3.5. startup class 的 configure 方法有什么作用？"></a>3.5. startup class 的 configure 方法有什么作用？</h2><p>这个方法来定义整个应用如何响应 HTTP 请求。它有几个比较重要的参数，application builder，Hosting environment, logo factory， 在这里我们可以配置一些中间件用来处理路径，验证和 session 等等。</p>
<h2 id="3-6-什么是-meta-packages？"><a href="#3-6-什么是-meta-packages？" class="headerlink" title="3.6. 什么是 meta packages？"></a>3.6. 什么是 meta packages？</h2><p>Meta packages 是指包含所有 ASP dot net code 依赖的一个包。叫做 Microsoft.AspNetCore.All</p>
<h2 id="3-7-什么是中间件？"><a href="#3-7-什么是中间件？" class="headerlink" title="3.7. 什么是中间件？"></a>3.7. 什么是中间件？</h2><p>中间件在这里是指注入到应用中处理请求和响应的组件。asp.net core 的中间件模型也是洋葱模型（和 node.js d Koa 一样）</p>
<h2 id="3-8-application-builder-的-use-和-run-方法有什么区别？"><a href="#3-8-application-builder-的-use-和-run-方法有什么区别？" class="headerlink" title="3.8. application builder 的 use 和 run 方法有什么区别？"></a>3.8. application builder 的 use 和 run 方法有什么区别？</h2><p>这两个方法都在 start up class 的 configure 方法里面调用。都是用来向应用请求管道里面添加中间件的。Use 方法可以调用下一个中间件的添加，而 run 不会。</p>
<h2 id="3-9-dot-net-core-管道（pipeline）里面的-map-拓展有什么作用"><a href="#3-9-dot-net-core-管道（pipeline）里面的-map-拓展有什么作用" class="headerlink" title="3.9. dot net core 管道（pipeline）里面的 map 拓展有什么作用?"></a>3.9. dot net core 管道（pipeline）里面的 map 拓展有什么作用?</h2><p>可以针对不同的路径添加不同的中间件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span><span class="params">(IApplicationBuilder app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  app.Map(<span class="string">&quot;/path1&quot;</span>, Middleware1);</span><br><span class="line">  app.Map(<span class="string">&quot;/path2&quot;</span>, Middleware2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-如何在-dot-net-core-中激活-session-功能"><a href="#3-10-如何在-dot-net-core-中激活-session-功能" class="headerlink" title="3.10. 如何在 dot net core 中激活 session 功能?"></a>3.10. 如何在 dot net core 中激活 session 功能?</h2><ol>
<li>首先要添加 session 包.</li>
<li>其次要在 config service 方法里面添加 session。</li>
<li>然后又在 configure 方法里面调用 usesession。</li>
</ol>
<h2 id="3-11-如何在-controller-中注入-service"><a href="#3-11-如何在-controller-中注入-service" class="headerlink" title="3.11. 如何在 controller 中注入 service?"></a>3.11. 如何在 controller 中注入 service?</h2><p>依赖注入的思想：</p>
<ol>
<li>在 config services 方法中配置这个 service。</li>
<li>在 controller 的构造函数中，添加这个依赖注入。</li>
</ol>
<h2 id="3-12-dot-net-core-里面的路径是如何处理的？"><a href="#3-12-dot-net-core-里面的路径是如何处理的？" class="headerlink" title="3.12. dot net core 里面的路径是如何处理的？"></a>3.12. dot net core 里面的路径是如何处理的？</h2><p>路径处理是用来为进入的请求寻找处理函数的机制。所有的路径在函数运行开始时进行注册。</p>
<p>主要有两种路径处理方式:</p>
<ol>
<li>常规路径处理就是用 MapRoute 的方式设定调用路径</li>
<li>属性路径处理是指在调用函数的上方设定一个路径属性。</li>
</ol>
<h2 id="3-13-application-builder-的-use-和-run-方法有什么区别？"><a href="#3-13-application-builder-的-use-和-run-方法有什么区别？" class="headerlink" title="3.13. application builder 的 use 和 run 方法有什么区别？"></a>3.13. application builder 的 use 和 run 方法有什么区别？</h2><p>这两个方法都在 start up class 的 configure 方法里面调用。都是用来向应用请求管道里面添加中间件的。Use 方法可以调用下一个中间件的添加，而 run 不会。</p>
<h2 id="3-14-依赖注入后的服务生命周期"><a href="#3-14-依赖注入后的服务生命周期" class="headerlink" title="3.14. 依赖注入后的服务生命周期?"></a>3.14. 依赖注入后的服务生命周期?</h2><p>在 dot net core 中，我们不需要关心如何释放这些服务, 因为系统会帮我们释放掉。有三种服务的生命周期。</p>
<ol>
<li>单实例服务， 通过 add singleton 方法来添加。在注册时即创建服务, 在随后的请求中都使用这一个服务。</li>
<li>短暂服务, 通过 add transient 方法来添加。是一种轻量级的服务，用于无状态服务的操作。</li>
<li>作用域服务，一个新的请求会创建一个服务实例。使用 add scoped 方法来添加。</li>
</ol>
<h2 id="3-15-什么么是-Razor-页面"><a href="#3-15-什么么是-Razor-页面" class="headerlink" title="3.15. 什么么是 Razor 页面?"></a>3.15. 什么么是 Razor 页面?</h2><p>是 dot net core 中支持 ASP 网页表格的一种开发模型。@page 作为页面的起始标志。可以看做是 asp.net core 使用的模板引擎。</p>
<h2 id="3-16-如何在-Razor-页面中实现数据模型绑定"><a href="#3-16-如何在-Razor-页面中实现数据模型绑定" class="headerlink" title="3.16. 如何在 Razor 页面中实现数据模型绑定?"></a>3.16. 如何在 Razor 页面中实现数据模型绑定?</h2><p>使用 bindproperty 属性。</p>
<h2 id="3-17-Server-Transfer-和-Response-Redirect-的区别是什么"><a href="#3-17-Server-Transfer-和-Response-Redirect-的区别是什么" class="headerlink" title="3.17. Server.Transfer 和 Response.Redirect 的区别是什么"></a>3.17. Server.Transfer 和 Response.Redirect 的区别是什么</h2><ol>
<li>Server.Transfer 仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；</li>
<li>Response.Redirect 则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。</li>
</ol>
<h2 id="3-18-API，什么时候用-Get-Post-Put-Delete"><a href="#3-18-API，什么时候用-Get-Post-Put-Delete" class="headerlink" title="3.18. API，什么时候用 Get/Post/Put/Delete"></a>3.18. API，什么时候用 Get/Post/Put/Delete</h2><ol>
<li>GET： 查询</li>
<li>POST ：创建对象</li>
<li>PUT： 修改对象</li>
<li>DELETE：删除</li>
</ol>
<h1 id="4-C"><a href="#4-C" class="headerlink" title="4. C#"></a>4. C#</h1><h2 id="4-1-一个单例（Singleton）类"><a href="#4-1-一个单例（Singleton）类" class="headerlink" title="4.1. 一个单例（Singleton）类"></a>4.1. 一个单例（Singleton）类</h2><p>单线程下的简单实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MySingleton</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">// 禁止被实例化</span></span><br><span class="line">  <span class="keyword">public</span> readonly <span class="keyword">static</span> MySingletonInstance = <span class="keyword">new</span> MySingleton();	<span class="comment">// 程序加载时就会初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全的加锁双检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MySingleton _instance = null;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> readonly object SynObject = <span class="keyword">new</span> object();</span><br><span class="line"></span><br><span class="line">    MySingleton() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (null == _instance)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (SynObject)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (null == _instance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _instance = <span class="keyword">new</span> MySingleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-abstract-class-和-interface-有什么区别"><a href="#4-2-abstract-class-和-interface-有什么区别" class="headerlink" title="4.2. abstract class 和 interface 有什么区别?"></a>4.2. abstract class 和 interface 有什么区别?</h2><p>相同点：都不能被直接实例化，都可以通过继承实现其抽象方法。</p>
<p>不同点：</p>
<ol>
<li>接口支持多继承；抽象类不能实现多继承。</li>
<li>接口只能定义行为；抽象类既可以定义行为，还可能提供实现。</li>
<li>接口只包含方法(Method)、属性(Property)、索引器(Index)、事件(Event)的签名，但不能定义字段和包含实现的方法；</li>
<li>抽象类可以定义字段、属性、包含有实现的方法。</li>
</ol>
<h2 id="4-3-是否可以继承-String-类"><a href="#4-3-是否可以继承-String-类" class="headerlink" title="4.3. 是否可以继承 String 类?"></a>4.3. 是否可以继承 String 类?</h2><p>String 类是 sealed 类故不可以继承。</p>
<h2 id="4-4-StringBuilder-和-String-的区别？"><a href="#4-4-StringBuilder-和-String-的区别？" class="headerlink" title="4.4. StringBuilder 和 String 的区别？"></a>4.4. StringBuilder 和 String 的区别？</h2><p>String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder，不要使用 String。<br>但是简单的字符拼接，String 还是首选。（100？次以内用 String，以上用 StringBuilder）</p>
<h2 id="4-5-什么情况下会用到虚方法？它与接口有什么不同？"><a href="#4-5-什么情况下会用到虚方法？它与接口有什么不同？" class="headerlink" title="4.5. 什么情况下会用到虚方法？它与接口有什么不同？"></a>4.5. 什么情况下会用到虚方法？它与接口有什么不同？</h2><ol>
<li>子类重新定义父类的某一个方法时，必须把父类的方法定义为 virtual</li>
<li>在定义接口中不能有方法体，虚方法可以。</li>
<li>实现时,子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。</li>
</ol>
<h2 id="4-6-string、String；int、Int32；Boolean、bool-的区别"><a href="#4-6-string、String；int、Int32；Boolean、bool-的区别" class="headerlink" title="4.6. string、String；int、Int32；Boolean、bool 的区别"></a>4.6. string、String；int、Int32；Boolean、bool 的区别</h2><p>String、Int32、Boolean 等都属于.Net 中定义的类，而 string、int、bool 相当于 C#中对这些类定义的别名。CTS。</p>
<h2 id="4-7-private、-protected、-public、-internal-修饰符的访问权限。"><a href="#4-7-private、-protected、-public、-internal-修饰符的访问权限。" class="headerlink" title="4.7. private、 protected、 public、 internal 修饰符的访问权限。"></a>4.7. private、 protected、 public、 internal 修饰符的访问权限。</h2><ol>
<li>private : 私有成员, 在类的内部才可以访问。</li>
<li>protected : 保护成员，该类内部和继承类中可以访问。</li>
<li>public : 公共成员，完全公开，没有访问限制。</li>
<li>internal: 当前程序集内可以访问。</li>
</ol>
<h2 id="4-8-C-中的委托是什么？事件是不是一种委托？事件和委托的关系。"><a href="#4-8-C-中的委托是什么？事件是不是一种委托？事件和委托的关系。" class="headerlink" title="4.8. C#中的委托是什么？事件是不是一种委托？事件和委托的关系。"></a>4.8. C#中的委托是什么？事件是不是一种委托？事件和委托的关系。</h2><p>委托可以把一个方法作为参数代入另一个方法，可以理解为指向一个函数的指针。<br>换个说法来解释，委托就是函数指针，事件就是保存多个函数指针的数组。</p>
<p>事件和委托的区别如下：</p>
<ol>
<li>事件只能在方法的外部进行声明，而委在方法的外部和内部都可以声明。</li>
<li>事件只能在类的内部触发，不能在类的外部触发。而委托在类的内部和外都都可以触发。</li>
<li>委托一般用于回调，而事件用于外部接口。例如在观察者模式中，在被观察者中可以声明一个事件作为外部观察者注册的接口。</li>
</ol>
<h2 id="4-9-override-与重载（overload）的区别"><a href="#4-9-override-与重载（overload）的区别" class="headerlink" title="4.9. override 与重载（overload）的区别"></a>4.9. override 与重载（overload）的区别</h2><ol>
<li>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。</li>
<li>Override 是进行基类中函数的重写。Override 是面向对象的概念</li>
</ol>
<h2 id="4-10-什么是装箱-boxing-和拆箱-unboxing"><a href="#4-10-什么是装箱-boxing-和拆箱-unboxing" class="headerlink" title="4.10. 什么是装箱(boxing)和拆箱(unboxing)"></a>4.10. 什么是装箱(boxing)和拆箱(unboxing)</h2><p>装箱：从值类型接口转换到引用类型。<br>拆箱：从引用类型转换到值类型。</p>
<p>——–END——–</p>
<blockquote>
<p>参考:<br><a target="_blank" rel="noopener" href="https://www.webtrainingroom.com/interview/asp-net-core-interview-questions-answers">https://www.webtrainingroom.com/interview/asp-net-core-interview-questions-answers</a> &gt; <a target="_blank" rel="noopener" href="https://www.talkingdotnet.com/asp-net-core-interview-questions/">https://www.talkingdotnet.com/asp-net-core-interview-questions/</a></p>
</blockquote>
<blockquote>
<p>—————- END —————-</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/12/Vue-js-Interview-Questions-and-Answers-2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/Vue-js-Interview-Questions-and-Answers-2021/" class="post-title-link" itemprop="url">2021 Vue.js 面试题汇总及答案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 15:10:23" itemprop="dateCreated datePublished" datetime="2021-04-12T15:10:23+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-14 13:36:52" itemprop="dateModified" datetime="2021-04-14T13:36:52+08:00">2021-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">1. 基本问题</a><ul>
<li><a href="#11-vuejs-%E7%9A%84%E7%89%B9%E7%82%B9">1.1. Vue.js 的特点</a></li>
<li><a href="#12-vuejs-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">1.2. Vue.js 双向绑定的原理</a></li>
<li><a href="#13-vuejs-30-%E6%94%BE%E5%BC%83defineproperty-%E4%BD%BF%E7%94%A8proxy%E7%9A%84%E5%8E%9F%E5%9B%A0">1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因</a></li>
<li><a href="#14-vue-2-%E4%B8%AD%E7%BB%99-data-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</a></li>
<li><a href="#15-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB">1.5. Computed和Watch的区别</a></li>
<li><a href="#16-computed-%E5%92%8C-methods-%E7%9A%84%E5%8C%BA%E5%88%AB">1.6. Computed 和 Methods 的区别</a></li>
<li><a href="#17-%E8%99%9A%E6%8B%9Fdomdiff%E7%AE%97%E6%B3%95">1.7. 虚拟DOM，diff算法</a></li>
<li><a href="#18-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81virtual-dom">1.8. 为何需要Virtual DOM？</a></li>
<li><a href="#19-%E8%BF%87%E6%BB%A4%E5%99%A8-filter">1.9. 过滤器 (Filter)</a></li>
<li><a href="#110-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8">1.10. 常见的事件修饰符及其作用</a></li>
<li><a href="#111-v-show%E6%8C%87%E4%BB%A4%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">1.11. v-show指令和v-if指令的区别是什么？</a></li>
<li><a href="#112-v-model-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88">1.12. v-model 是如何实现的，语法糖实际是什么</a></li>
<li><a href="#113-data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1">1.13. data为什么是一个函数而不是对象</a></li>
<li><a href="#114-vue-template-%E5%88%B0-render-%E7%9A%84%E8%BF%87%E7%A8%8B">1.14. Vue template 到 render 的过程</a></li>
<li><a href="#115-vue-data-%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%8E%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%97">1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></li>
<li><a href="#116-axios%E6%98%AF%E4%BB%80%E4%B9%88">1.16. axios是什么</a></li>
<li><a href="#117-sass%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">1.17. sass是什么？如何在vue中安装和使用？</a></li>
<li><a href="#118-vuejs%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81">1.18. Vue.js页面闪烁</a></li>
<li><a href="#119-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%A4%AA%E6%B7%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.19. 如何解决数据层级结构太深的问题</a></li>
<li><a href="#120-%E5%9C%A8-vue-js%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%B0%83%E7%94%A8api%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%B7%A8%E5%9F%9F">1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域</a></li>
<li><a href="#121-%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5">1.21. 批量异步更新策略</a></li>
<li><a href="#122-vue-%E7%9A%84-nexttick-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.22. vue 的 nextTick 方法的实现原理</a></li>
<li><a href="#123-vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0-">1.23. Vue 组件 data 为什么必须是函数 ?</a></li>
<li><a href="#124-v-if%E5%92%8Cv-for%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">1.24. v-if和v-for一起使用的弊端及解决办法</a></li>
<li><a href="#125-vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">1.25. vue常用指令</a></li>
<li><a href="#126-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">1.26. 组件传值方式有哪些</a></li>
<li><a href="#127-vue-loader%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E5%93%AA%E4%BA%9B">1.27. vue-loader是什么？使用它的用途有哪些？</a></li>
</ul>
</li>
<li><a href="#2-%E7%BB%84%E4%BB%B6-component">2. 组件 Component</a><ul>
<li><a href="#21-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6-%E7%BC%96%E5%86%99%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%88%99">2.1. vue中如何编写可复用的组件 （编写组件的原则）</a></li>
<li><a href="#22-%E5%A6%82%E4%BD%95%E8%AE%A9css%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B5%B7%E4%BD%9C%E7%94%A8">2.2. 如何让CSS只在当前组件中起作用？</a></li>
<li><a href="#23-keep-alive%E6%98%AF%E4%BB%80%E4%B9%88">2.3. keep-alive是什么？</a></li>
<li><a href="#24-%E5%A6%82%E4%BD%95%E5%9C%A8-vue-js%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">2.4. 如何在 Vue. js动态插入图片</a></li>
<li><a href="#25-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F">2.5. 父子组件的生命周期顺序</a></li>
</ul>
</li>
<li><a href="#3-vuex">3. Vuex</a><ul>
<li><a href="#31-vuex%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">3.1. vuex的核心概念</a></li>
<li><a href="#32-vuex%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E5%AE%83">3.2. vuex是什么？怎么使用？哪种功能场景使用它？</a></li>
<li><a href="#33-%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E6%8B%86%E5%88%86%E5%90%84%E8%87%AA%E7%9A%84state%E6%AF%8F%E5%9D%97%E5%B0%8F%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8A%B6%E6%80%81%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E5%85%AC%E5%85%B1%E7%9A%84%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%B4%E6%8A%A4%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83%E8%BF%99%E5%9D%97">3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块</a></li>
</ul>
</li>
<li><a href="#4-router">4. Router</a><ul>
<li><a href="#41-vue-router%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F">4.1. vue-router路由的两种模式</a></li>
<li><a href="#42-vue-router%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">4.2. vue-router如何定义嵌套路由</a></li>
<li><a href="#43-vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90">4.3. vue-router有哪几种导航钩子？</a></li>
<li><a href="#44-route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB">4.4. $route和$router的区别</a></li>
<li><a href="#45-%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F">4.5. 路由之间跳转的方式</a></li>
<li><a href="#46-active-class%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7">4.6. active-class是哪个组件的属性</a></li>
</ul>
</li>
</ul>
<h1 id="1-基本问题"><a href="#1-基本问题" class="headerlink" title="1. 基本问题"></a>1. 基本问题</h1><h2 id="1-1-Vue-js-的特点"><a href="#1-1-Vue-js-的特点" class="headerlink" title="1.1. Vue.js 的特点"></a>1.1. Vue.js 的特点</h2><ul>
<li>易用： 简单，易学，上手快</li>
<li>灵活： （渐进式）不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</li>
<li>高效： 20kB min+gzip 运行大小；超快虚拟 DOM；最省心的优化</li>
<li>双向绑定：开发效率高</li>
<li>基于组件的代码共享</li>
<li>Web项目工程化，增加可读性、可维护性</li>
</ul>
<h2 id="1-2-Vue-js-双向绑定的原理"><a href="#1-2-Vue-js-双向绑定的原理" class="headerlink" title="1.2. Vue.js 双向绑定的原理"></a>1.2. Vue.js 双向绑定的原理</h2><p>Vue.js 2.0  采用数据劫持（Proxy 模式）结合发布者-订阅者模式（PubSub 模式）的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<blockquote>
<p>Vue.js 3.0, 放弃了Object.defineProperty ，使用更快的ES6原生 Proxy (访问对象拦截器, 也称代理器)</p>
</blockquote>
<p>步骤：</p>
<ol>
<li><p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
</li>
<li><p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
</li>
<li><p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
</li>
<li><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
</li>
</ol>
<h2 id="1-3-Vue-js-3-0-放弃defineProperty-使用Proxy的原因"><a href="#1-3-Vue-js-3-0-放弃defineProperty-使用Proxy的原因" class="headerlink" title="1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因"></a>1.3. Vue.js 3.0 放弃defineProperty, 使用Proxy的原因</h2><p>Object.defineProperty缺陷</p>
<ol>
<li>监控到数组下标的变化时，开销很大。所以Vue.js放弃了下标变化的检测；</li>
<li>Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。Object.defineProperty需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</li>
<li>Object.defineProperty对新增属性需要手动进行Observe。vue2时需要使用 vm.$set 才能保证新增的属性也是响应式</li>
<li>Proxy支持13种拦截操作，这是defineProperty所不具有的</li>
<li>Proxy 作为新标准，长远来看，JS引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化</li>
</ol>
<h2 id="1-4-Vue-2-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#1-4-Vue-2-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a>1.4. Vue 2 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h2><p>视图并未刷新。这是因为在Vue实例创建时，新属性并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：<code>this.$set(this.obj, &#39;new_property&#39;, &#39;new_value&#39;)</code></p>
<h2 id="1-5-Computed和Watch的区别"><a href="#1-5-Computed和Watch的区别" class="headerlink" title="1.5. Computed和Watch的区别"></a>1.5. Computed和Watch的区别</h2><ol>
<li>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。</li>
</ol>
<blockquote>
<p>运用场景：</p>
</blockquote>
<ol>
<li>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</li>
<li>多个因素影响一个显示，用Computed；一个因素的变化影响多个其他因素、显示，用Watch;</li>
</ol>
<h2 id="1-6-Computed-和-Methods-的区别"><a href="#1-6-Computed-和-Methods-的区别" class="headerlink" title="1.6. Computed 和 Methods 的区别"></a>1.6. Computed 和 Methods 的区别</h2><ol>
<li>computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，</li>
<li>method 调用总会执行该函数</li>
</ol>
<h2 id="1-7-虚拟DOM，diff算法"><a href="#1-7-虚拟DOM，diff算法" class="headerlink" title="1.7. 虚拟DOM，diff算法"></a>1.7. 虚拟DOM，diff算法</h2><p>（1）让我们不用直接操作DOM元素，只操作数据便可以重新渲染页面<br>（2）虚拟dom是为了解决浏览器性能问题而被设计出来的<br>当操作数据时，将改变的dom元素缓存起来，都计算完后再通过比较映射到真实的dom树上<br>（3）diff算法比较新旧虚拟dom。如果节点类型相同，则比较数据，修改数据；如果节点不同，直接干掉节点及所有子节点，插入新的节点；如果给每个节点都设置了唯一的key，就可以准确的找到需要改变的内容，否则就会出现修改一个地方导致其他地方都改变的情况。比如A-B-C-D, 我要插入新节点A-B-M-C-D,实际上改变的了C和D。但是设置了key，就可以准确的找到B C并插入</p>
<h2 id="1-8-为何需要Virtual-DOM？"><a href="#1-8-为何需要Virtual-DOM？" class="headerlink" title="1.8. 为何需要Virtual DOM？"></a>1.8. 为何需要Virtual DOM？</h2><ol>
<li>具备跨平台的优势</li>
<li>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。</li>
<li>提升渲染性能</li>
</ol>
<h2 id="1-9-过滤器-Filter"><a href="#1-9-过滤器-Filter" class="headerlink" title="1.9. 过滤器 (Filter)"></a>1.9. 过滤器 (Filter)</h2><p>在Vue中使用filters来过滤(格式化)数据，filters不会修改数据，而是过滤(格式化)数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示。<br>使用场景： 比如需要处理时间、数字等的的显示格式；</p>
<h2 id="1-10-常见的事件修饰符及其作用"><a href="#1-10-常见的事件修饰符及其作用" class="headerlink" title="1.10. 常见的事件修饰符及其作用"></a>1.10. 常见的事件修饰符及其作用</h2><ol>
<li><code>.stop</code>：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</li>
<li><code>.prevent</code> ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li><code>.capture</code> ：当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。如 div1中嵌套div2中嵌套div3.capture中嵌套div4，那么执行顺序为：div3=》div4=》div2=》div1</li>
<li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li><code>.once</code> ：只会触发一次。</li>
</ol>
<h2 id="1-11-v-show指令和v-if指令的区别是什么？"><a href="#1-11-v-show指令和v-if指令的区别是什么？" class="headerlink" title="1.11. v-show指令和v-if指令的区别是什么？"></a>1.11. v-show指令和v-if指令的区别是什么？</h2><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
<h2 id="1-12-v-model-是如何实现的，语法糖实际是什么"><a href="#1-12-v-model-是如何实现的，语法糖实际是什么" class="headerlink" title="1.12. v-model 是如何实现的，语法糖实际是什么"></a>1.12. v-model 是如何实现的，语法糖实际是什么</h2><ol>
<li>作用在表单元素上<code>v-model=&quot;message&quot;</code>等同于<code>v-bind:value=&quot;message&quot;  v-on:input=&quot;message=$event.target.value&quot;</code></li>
<li>作用在组件上, 本质是一个父子组件通信的语法糖，通过prop和$.emit实现, 等同于<code>:value=&quot;message&quot; @input=&quot; $emit(&#39;input&#39;, $event.target.value)&quot;</code></li>
</ol>
<h2 id="1-13-data为什么是一个函数而不是对象"><a href="#1-13-data为什么是一个函数而不是对象" class="headerlink" title="1.13. data为什么是一个函数而不是对象"></a>1.13. data为什么是一个函数而不是对象</h2><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，我们更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当我们每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h2 id="1-14-Vue-template-到-render-的过程"><a href="#1-14-Vue-template-到-render-的过程" class="headerlink" title="1.14. Vue template 到 render 的过程"></a>1.14. Vue template 到 render 的过程</h2><ol>
<li>调用parse方法将template转化为ast（抽象语法树, abstract syntax tree）</li>
<li>对静态节点做优化。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</li>
<li>生成渲染函数. 渲染的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名，子节点，文本等等）</li>
</ol>
<h2 id="1-15-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#1-15-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>1.15. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h2><p>不会立即同步执行重新渲染。<br>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。<br>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<br>然后，在下一个的事件循环”tick”中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h2 id="1-16-axios是什么"><a href="#1-16-axios是什么" class="headerlink" title="1.16. axios是什么"></a>1.16. axios是什么</h2><p>易用、简洁且高效的http库， 支持node端和浏览器端，支持Promise，支持拦截器等高级配置。</p>
<h2 id="1-17-sass是什么？如何在vue中安装和使用？"><a href="#1-17-sass是什么？如何在vue中安装和使用？" class="headerlink" title="1.17. sass是什么？如何在vue中安装和使用？"></a>1.17. sass是什么？如何在vue中安装和使用？</h2><p>sass是一种CSS预编译语言安装和使用步骤如下。</p>
<ol>
<li>用npm安装加载程序（ sass-loader、 css-loader等加载程序)。</li>
<li>在 webpack.config.js中配置sass加载程序。</li>
</ol>
<h2 id="1-18-Vue-js页面闪烁"><a href="#1-18-Vue-js页面闪烁" class="headerlink" title="1.18. Vue.js页面闪烁"></a>1.18. Vue.js页面闪烁</h2><p>Vue. js提供了一个v-cloak指令，该指令一直保持在元素上，直到关联实例结束编译。当和CSS一起使用时，这个指令可以隐藏未编译的标签，直到实例编译结束。用法如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak]&#123; </span><br><span class="line"> display:none; </span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-19-如何解决数据层级结构太深的问题"><a href="#1-19-如何解决数据层级结构太深的问题" class="headerlink" title="1.19. 如何解决数据层级结构太深的问题"></a>1.19. 如何解决数据层级结构太深的问题</h2><p>在开发业务时，经常会岀现异步获取数据的情况，有时数据层次比较深，如以下代码: <code>span &#39;v-text=&quot;a.b.c.d&quot;&gt;&lt;/span&gt;</code>, 可以使用vm.$set手动定义一层数据: <code>vm.$set(&quot;demo&quot;，a.b.c.d)</code></p>
<h2 id="1-20-在-Vue-js开发环境下调用API接口，如何避免跨域"><a href="#1-20-在-Vue-js开发环境下调用API接口，如何避免跨域" class="headerlink" title="1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域"></a>1.20. 在 Vue. js开发环境下调用API接口，如何避免跨域</h2><p>config/ index.js内对 proxyTable项配置代理。</p>
<h2 id="1-21-批量异步更新策略"><a href="#1-21-批量异步更新策略" class="headerlink" title="1.21. 批量异步更新策略"></a>1.21. 批量异步更新策略</h2><p>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>换句话说，只要观察到数据变化，就会自动开启一个队列，并缓冲在同一个事件循环中发生的所以数据改变。在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。</p>
<h2 id="1-22-vue-的-nextTick-方法的实现原理"><a href="#1-22-vue-的-nextTick-方法的实现原理" class="headerlink" title="1.22. vue 的 nextTick 方法的实现原理"></a>1.22. vue 的 nextTick 方法的实现原理</h2><ol>
<li>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行</li>
<li>microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li>
</ol>
<h2 id="1-23-Vue-组件-data-为什么必须是函数"><a href="#1-23-Vue-组件-data-为什么必须是函数" class="headerlink" title="1.23. Vue 组件 data 为什么必须是函数 ?"></a>1.23. Vue 组件 data 为什么必须是函数 ?</h2><p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>
<h2 id="1-24-v-if和v-for一起使用的弊端及解决办法"><a href="#1-24-v-if和v-for一起使用的弊端及解决办法" class="headerlink" title="1.24. v-if和v-for一起使用的弊端及解决办法"></a>1.24. v-if和v-for一起使用的弊端及解决办法</h2><p>由于v-for的优先级比v-if高，所以导致每循环一次就会去v-if一次，而v-if是通过创建和销毁dom元素来控制元素的显示与隐藏，所以就会不停的去创建和销毁元素，造成页面卡顿，性能下降。</p>
<p>解决办法：</p>
<ol>
<li>在v-for的外层或内层包裹一个元素来使用v-if</li>
<li>用computed处理</li>
</ol>
<h2 id="1-25-vue常用指令"><a href="#1-25-vue常用指令" class="headerlink" title="1.25. vue常用指令"></a>1.25. vue常用指令</h2><ol>
<li>v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）</li>
<li>v-bind 动态绑定 作用： 及时对页面的数据进行更改</li>
<li>v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li>
<li>v-for 格式： v-for=”字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)</li>
<li>v-show 显示内容 （同angular中的ng-show）</li>
<li>v-hide 隐藏内容（同angular中的ng-hide）</li>
<li>v-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）</li>
<li>v-else-if 必须和v-if连用</li>
<li>v-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误</li>
<li>v-text 解析文本</li>
<li>v-html 解析html标签</li>
<li>v-bind:class 三种绑定方法 1、对象型 ‘{red:isred}’ 2、三元型 ‘isred?”red”:”blue”‘ 3、数组型 ‘[{red:”isred”},{blue:”isblue”}]’</li>
<li>v-once 进入页面时 只渲染一次 不在进行渲染</li>
<li>v-cloak 防止闪烁</li>
<li>v-pre 把标签内部的元素原位输出</li>
</ol>
<h2 id="1-26-组件传值方式有哪些"><a href="#1-26-组件传值方式有哪些" class="headerlink" title="1.26. 组件传值方式有哪些"></a>1.26. 组件传值方式有哪些</h2><ol>
<li>父传子：子组件通过props[‘xx’] 来接收父组件传递的属性 xx 的值</li>
<li>子传父：子组件通过 this.$emit(‘fnName’,value) 来传递,父组件通过接收 fnName 事件方法来接收回调</li>
<li>其他方式：通过创建一个bus，进行传值</li>
<li>使用Vuex</li>
</ol>
<h2 id="1-27-vue-loader是什么？使用它的用途有哪些？"><a href="#1-27-vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="1.27. vue-loader是什么？使用它的用途有哪些？"></a>1.27. vue-loader是什么？使用它的用途有哪些？</h2><h1 id="2-组件-Component"><a href="#2-组件-Component" class="headerlink" title="2. 组件 Component"></a>2. 组件 Component</h1><h2 id="2-1-vue中如何编写可复用的组件-（编写组件的原则）"><a href="#2-1-vue中如何编写可复用的组件-（编写组件的原则）" class="headerlink" title="2.1. vue中如何编写可复用的组件 （编写组件的原则）"></a>2.1. vue中如何编写可复用的组件 （编写组件的原则）</h2><ol>
<li>以组件功能命名</li>
<li>只负责ui的展示和交互动画，不要在组件里与服务器打交道（获取异步数据等）</li>
<li>可复用组件不会因组件使用的位置、场景而变化。尽量减少对外部条件的依赖。</li>
</ol>
<h2 id="2-2-如何让CSS只在当前组件中起作用？"><a href="#2-2-如何让CSS只在当前组件中起作用？" class="headerlink" title="2.2. 如何让CSS只在当前组件中起作用？"></a>2.2. 如何让CSS只在当前组件中起作用？</h2><p>在每一个Vue.js组件中都可以定义各自的CSS、 JavaScript代码。如果希望组件内写的CSS只对当前组件起作用，只需要在Style标签添加Scoped属性，即<style scoped></style>。</p>
<h2 id="2-3-keep-alive是什么？"><a href="#2-3-keep-alive是什么？" class="headerlink" title="2.3. keep-alive是什么？"></a>2.3. keep-alive是什么？</h2><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>两个重要属性，include 缓存组件名称，exclude 不需要缓存的组件名称。</p>
<h2 id="2-4-如何在-Vue-js动态插入图片"><a href="#2-4-如何在-Vue-js动态插入图片" class="headerlink" title="2.4. 如何在 Vue. js动态插入图片"></a>2.4. 如何在 Vue. js动态插入图片</h2><p>对“src”属性插值将导致404请求错误。应使用 v-bind:src （简写<code>:src</code>）格式代替。</p>
<h2 id="2-5-父子组件的生命周期顺序"><a href="#2-5-父子组件的生命周期顺序" class="headerlink" title="2.5. 父子组件的生命周期顺序"></a>2.5. 父子组件的生命周期顺序</h2><ol>
<li>加载渲染过程：<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
<li>子组件更新过程：父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
<li>父组件更新过程：父beforeUpdate-&gt;父updated</li>
<li>销毁过程：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ol>
<h1 id="3-Vuex"><a href="#3-Vuex" class="headerlink" title="3. Vuex"></a>3. Vuex</h1><h2 id="3-1-vuex的核心概念"><a href="#3-1-vuex的核心概念" class="headerlink" title="3.1. vuex的核心概念"></a>3.1. vuex的核心概念</h2><ol>
<li>state =&gt; 基本数据 </li>
<li>getters =&gt; 从基本数据派生的数据 </li>
<li>mutations =&gt; 修改数据，同步 </li>
<li>actions =&gt; 修改数据，异步  (Action 提交的是 mutation，而不是直接变更状态)</li>
<li>modules =&gt; 模块化Vuex</li>
</ol>
<h2 id="3-2-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#3-2-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="3.2. vuex是什么？怎么使用？哪种功能场景使用它？"></a>3.2. vuex是什么？怎么使用？哪种功能场景使用它？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态，主要是为了多页面、多组件之间的通信。<br>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。如果你的项目很简单，最好不要使用 Vuex，对于大型项目，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。</p>
<h2 id="3-3-多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块"><a href="#3-3-多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块" class="headerlink" title="3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块"></a>3.3. 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块</h2><ol>
<li>公共的数据部分可以提升至和他们最近的父组件，由父组件派发</li>
<li>公共数据可以放到vuex中统一管理，各组件分别获取</li>
</ol>
<h1 id="4-Router"><a href="#4-Router" class="headerlink" title="4. Router"></a>4. Router</h1><h2 id="4-1-vue-router路由的两种模式"><a href="#4-1-vue-router路由的两种模式" class="headerlink" title="4.1. vue-router路由的两种模式"></a>4.1. vue-router路由的两种模式</h2><p>vue-router中默认使用的是hash模式</p>
<ol>
<li>hash模式, 带#。如：<a target="_blank" rel="noopener" href="http://localhost:8080/#/pageA%E3%80%82%E6%94%B9%E5%8F%98hash%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E8%BA%AB%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BB%BB%E4%BD%95%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E4%BD%9C%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81%E5%92%8Curl%E5%B7%B2%E7%BB%8F%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E4%BA%86%E3%80%82">http://localhost:8080/#/pageA。改变hash，浏览器本身不会有任何请求服务器动作的，但是页面状态和url已经关联起来了。</a></li>
<li>history模式，不带#， 如：<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 正常的而路径，并没有#。基于HTML5的 pushState、replaceState实现</li>
</ol>
<h2 id="4-2-vue-router如何定义嵌套路由"><a href="#4-2-vue-router如何定义嵌套路由" class="headerlink" title="4.2. vue-router如何定义嵌套路由"></a>4.2. vue-router如何定义嵌套路由</h2><p>通过children 数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&quot;/parentPage&quot;</span>,</span><br><span class="line">      component: testPage,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&quot;/childrenA&quot;</span>,</span><br><span class="line">          component: childrenComponentA,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">&quot;/childrenB&quot;</span>,</span><br><span class="line">          component: childrenComponentB,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 其他和parentPage平级的路由</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-3-vue-router有哪几种导航钩子？"><a href="#4-3-vue-router有哪几种导航钩子？" class="headerlink" title="4.3. vue-router有哪几种导航钩子？"></a>4.3. vue-router有哪几种导航钩子？</h2><ol>
<li>全局导航钩子：router.beforeEach(to,from,next)</li>
<li>组件内的钩子beforeRouteEnter (to, from, next) beforeRouteUpdate (to, from, next) beforeRouteLeave (to, from, next)</li>
<li>单独路由独享组件 beforeEnter: (to, from, next)</li>
</ol>
<h2 id="4-4-route和-router的区别"><a href="#4-4-route和-router的区别" class="headerlink" title="4.4. $route和$router的区别"></a>4.4. $route和$router的区别</h2><ol>
<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>
<li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>
</ol>
<h2 id="4-5-路由之间跳转的方式"><a href="#4-5-路由之间跳转的方式" class="headerlink" title="4.5. 路由之间跳转的方式"></a>4.5. 路由之间跳转的方式</h2><ol>
<li>声明式（标签跳转） </li>
<li>编程式（ js跳转）</li>
</ol>
<h2 id="4-6-active-class是哪个组件的属性"><a href="#4-6-active-class是哪个组件的属性" class="headerlink" title="4.6. active-class是哪个组件的属性"></a>4.6. active-class是哪个组件的属性</h2><p>vue-router 模块 的router-link组件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/04/10/React-starter-2-React-Router-Dom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/React-starter-2-React-Router-Dom/" class="post-title-link" itemprop="url">React 入门（2）- 路由 React Router</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-10 22:11:55 / Modified: 22:39:52" itemprop="dateCreated datePublished" datetime="2021-04-10T22:11:55+08:00">2021-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#browserrouter%E4%B8%8Ehashrouter%E7%9A%84%E5%8C%BA%E5%88%AB">BrowserRouter与HashRouter的区别</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">安装和使用</a></li>
</ul>
<blockquote>
<p>环境:</p>
<ul>
<li>React 17.x</li>
<li>react-router-dom: 5.2</li>
</ul>
</blockquote>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>React 本身是一个极简的类库，并且遵循渐进式原则，所以是不带路由（Router）功能的。对于稍复杂些的应用，没有路由显然是不可以的，所以就需要引入路由（React Router）库。</p>
<p>React Router 从5.0开始只分为Core，Web 和Native3种。 从5.0开始，彻底将原本的针对网页使用的react-router的npm package命名改为了react-router-dom。也就是说，针对web应用，用react-router-dom吧。（本文暂不涉及Native)</p>
<blockquote>
<p>官方文档： <a target="_blank" rel="noopener" href="https://reacttraining.com/react-router/">https://reacttraining.com/react-router/</a></p>
</blockquote>
<h1 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h1><p>React Router 有2中模式，BrowserRouter与HashRouter，下面我们来看一下区别</p>
<ol>
<li>url表现形式不一样，看是否包含#</li>
</ol>
<ul>
<li>BrowserRouter没有，例如：<a target="_blank" rel="noopener" href="http://localhost:3000/about">http://localhost:3000/about</a></li>
<li>HashRouter的路径包含＃，例如：<a target="_blank" rel="noopener" href="http://localhost:3000/#/about">http://localhost:3000/#/about</a></li>
</ul>
<ol start="2">
<li>底层原理不一样</li>
</ol>
<ul>
<li>BrowserRouter使用的是HTML5的history API(window.history.pushState, popState)</li>
<li>HashRouter使用的是URL的哈希值。</li>
</ul>
<ol start="3">
<li>刷新后对路由state参数的影响</li>
</ol>
<ul>
<li>BrowserRouter没有任何影响，因为state保存在history对象中。</li>
<li>HashRouter刷新后会导致路由state参数的丢失。</li>
</ul>
<h1 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h1><ol>
<li><p>安装：<br><code>npm i react-router-dom</code></p>
</li>
<li><p>简单使用，<br>参考：<a target="_blank" rel="noopener" href="https://reactrouter.com/web/guides/quick-start">https://reactrouter.com/web/guides/quick-start</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/30/angular-perfromance-in-binding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/angular-perfromance-in-binding/" class="post-title-link" itemprop="url">angular绑定（脏检查）方面的性能优化技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-30 14:48:39" itemprop="dateCreated datePublished" datetime="2021-03-30T14:48:39+08:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-17 16:52:54" itemprop="dateModified" datetime="2021-04-17T16:52:54+08:00">2021-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%98%E5%8C%96">1. 为什么要优化</a></li>
<li><a href="#2-%E7%BC%96%E7%A8%8B%E4%B9%A0%E6%83%AF%E6%96%B9%E9%9D%A2">2. 编程习惯方面</a><ul>
<li><a href="#21-ngforof%E5%8A%A0%E5%85%A5trackby%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD">2.1. NgForOf，加入trackBy提升性能</a></li>
<li><a href="#22-angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">2.2. Angular数据绑定的三种方式</a></li>
<li><a href="#23-%E9%99%A4%E9%9D%9E%E9%9C%80%E8%A6%81%E9%83%BD%E6%98%AF%E7%94%A8%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A%E5%87%8F%E5%B0%91%E7%9B%91%E6%8E%A7%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0">2.3. 除非需要，都是用单向绑定，减少监控值的个数</a></li>
</ul>
</li>
<li><a href="#3-changedetectionstrategyonpush-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87">3. ChangeDetectionStrategy.OnPush 进行性能提升</a></li>
<li><a href="#4-%E5%88%A9%E7%94%A8ngzone-runoutsideangular%E4%BC%98%E5%8C%96">4. 利用ngzone-runOutsideAngular优化</a></li>
<li><a href="#5-%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E8%84%8F%E6%A3%80%E6%9F%A5-changedetectorref">5. 手动控制脏检查 ChangeDetectorRef</a></li>
<li><a href="#6-%E6%80%BB%E7%BB%93">6. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular: 8+</li>
</ul>
</blockquote>
<h1 id="1-为什么要优化"><a href="#1-为什么要优化" class="headerlink" title="1. 为什么要优化"></a>1. 为什么要优化</h1><p>双向绑定是一柄双刃剑，提高开发效率的同时，也牺牲了性能。当然，随着硬件性能的提升，Angular自身性能的提升，对于一般（中小）复杂度的应用，性能问题可以忽略不计。但是对于特殊场景，或复杂页面来说，我们就需要单独的处理数据绑定问题，否则就会有卡顿的现象，影响用户体验。</p>
<h1 id="2-编程习惯方面"><a href="#2-编程习惯方面" class="headerlink" title="2. 编程习惯方面"></a>2. 编程习惯方面</h1><p>平时的一些小技巧，小习惯，都可以改善Angular绑定方面的性能。</p>
<h2 id="2-1-NgForOf，加入trackBy提升性能"><a href="#2-1-NgForOf，加入trackBy提升性能" class="headerlink" title="2.1. NgForOf，加入trackBy提升性能"></a>2.1. NgForOf，加入trackBy提升性能</h2><p>trackBy定义如何跟踪可迭代项的更改的函数。在迭代器中添加、移动或删除条目时，指令必须重新渲染适当的 DOM 节点。为了最大程度地减少 DOM 中的搅动，仅重新渲染已更改的节点。</p>
<p>默认情况下，变更检测器假定对象实例标识可迭代对象。提供此函数后，指令将使用调用此函数的结果来标识项节点，而不是对象本身的标识。</p>
<h2 id="2-2-Angular数据绑定的三种方式"><a href="#2-2-Angular数据绑定的三种方式" class="headerlink" title="2.2. Angular数据绑定的三种方式"></a>2.2. Angular数据绑定的三种方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Name &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 1. 直接绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Classes &#123;&#123;item | classPipe&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- 2. pipe方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Classes &#123;&#123;classes(item)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!-- 3.绑定方法调用的结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>直接绑定： 大多数情况下，这都是性能最好的方式。</li>
<li>绑定方法调用的结果：在每个脏值检测过程中，classes方程都要被调用一遍。如果没有特殊需求，应尽量避免这种使用方式。</li>
<li>pipe方式： 它和绑定function类似，每次脏值检测classPipe都会被调用。不过Angular给pipe做了优化，加了缓存，如果item和上次相等，则直接返回结果。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let item of items; index as i; trackBy: trackByFn&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-除非需要，都是用单向绑定，减少监控值的个数"><a href="#2-3-除非需要，都是用单向绑定，减少监控值的个数" class="headerlink" title="2.3. 除非需要，都是用单向绑定，减少监控值的个数"></a>2.3. 除非需要，都是用单向绑定，减少监控值的个数</h2><p>对于一般数据来说，都是只需要展示给用户，不需要修改。那么对于这部分数据，使用单向绑定即可(ts-&gt;html).<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 也称插值绑定 --&gt;</span><br><span class="line"> &lt;span&gt;&#123;&#123;yourMessage&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<h1 id="3-ChangeDetectionStrategy-OnPush-进行性能提升"><a href="#3-ChangeDetectionStrategy-OnPush-进行性能提升" class="headerlink" title="3. ChangeDetectionStrategy.OnPush 进行性能提升"></a>3. ChangeDetectionStrategy.OnPush 进行性能提升</h1><p>对于一些很复杂的页面，上面的小技巧就不够用了，不过Angular也是考虑到这些了，提供了不少方法。<br>Angular 对比 AngularJS 在变化检测上由原来的双向检测(父-&gt;子，子-&gt;父)变为了单向(父-&gt;子)。所以每一次变化检测都会确定性地收敛。<br>Angular定义一个组件时，可以传入一个变化检测配置项为</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">changeDetection: ChangeDetectionStrategy.OnPush | ChangeDetectionStrategy.Default;</span><br></pre></td></tr></table></figure>

<p>onpush策略只判断输入的引用(如果是object)是否改变，来判断是否进行脏检查。因此，我们可以使用onpush策略来减少变化检测的开销。</p>
<h1 id="4-利用ngzone-runOutsideAngular优化"><a href="#4-利用ngzone-runOutsideAngular优化" class="headerlink" title="4. 利用ngzone-runOutsideAngular优化"></a>4. 利用ngzone-runOutsideAngular优化</h1><p>Angular依赖NgZone来监听异步操作，并从根部执行变化检测。换句话说，我们代码中的每一个 addEventListener都会触发脏检查。但是如果我们非常明确，有些addEventListener要执行的东西，不会（或者说可以忽略）影响数据结果，不想然他触发脏检查。比如监测scroll，监测鼠标事件等。</p>
<p>针对这种情况， 我们可以使用zone提供的runOutsideAngular，让这些事件不触发脏检查。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.zone.runOutsideAngular(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.document.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.bindMouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="5-手动控制脏检查-ChangeDetectorRef"><a href="#5-手动控制脏检查-ChangeDetectorRef" class="headerlink" title="5. 手动控制脏检查 ChangeDetectorRef"></a>5. 手动控制脏检查 ChangeDetectorRef</h1><p>Angular的ChangeDetectorRef实例上提供了可以绑定或解绑某个组件脏检查的方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeDetectorRef</span> </span>&#123;</span><br><span class="line">  markForCheck() : <span class="built_in">void</span>     <span class="comment">// 通知框架进行变化检查/Change Detection</span></span><br><span class="line">  detach() : <span class="built_in">void</span>           <span class="comment">// 禁止脏检查</span></span><br><span class="line">  detectChanges() : <span class="built_in">void</span>    <span class="comment">// 手工触发脏检查， 从该组件到各个子组件执行一次变化检测</span></span><br><span class="line">  checkNoChanges() : <span class="built_in">void</span></span><br><span class="line">  reattach() : <span class="built_in">void</span>         <span class="comment">// detach逆操作，启用脏检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ol>
<li>平时的一些小习惯，都可以提高angular的性能；</li>
<li>针对复杂应用，或者当出现卡顿时，我们也是有办法的！</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/07/CSS-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/CSS-interview-qa/" class="post-title-link" itemprop="url">CSS面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-07 13:06:00" itemprop="dateCreated datePublished" datetime="2021-03-07T13:06:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-09 16:43:47" itemprop="dateModified" datetime="2021-03-09T16:43:47+08:00">2021-03-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSS实现水平垂直居中"><a href="#CSS实现水平垂直居中" class="headerlink" title="CSS实现水平垂直居中"></a>CSS实现水平垂直居中</h1><ol>
<li>margin: auto;实现绝对定位元素的居中</li>
</ol>
<pre><code class="css">    .center-vertical&#123;
        width: 100px;
        height: 100px;
        background: orange;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
    &#125;
</code></pre>
<ol start="2">
<li>CSS3.0弹性布局<pre><code class="css">   html,
   body &#123;
     width: 100%;
     height: 100%;
   &#125;
   body &#123;
     display: flex;
     align-items: center;
     justify-content: center; /* 定义body的元素水平居中 */
   &#125;
   .content &#123;
     width: 300px;
     height: 300px;
     background: orange;
   &#125;
</code></pre>
</li>
</ol>
<h1 id="行内元素有哪些？块级元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？"></a>行内元素有哪些？块级元素有哪些？</h1><ol>
<li>行内元素有：<code>a b span img input select strong</code></li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li>
<li>常见的空元素：    <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ol>
<h1 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h1><ol>
<li>新增各种CSS选择器  （: not(.input)：）</li>
<li>圆角            （border-radius:8px）</li>
<li>多列布局      （multi-column layout）</li>
<li>阴影和反射   （Shadow\Reflect）</li>
<li>文字特效      （text-shadow）</li>
<li>文字渲染      （Text-decoration）</li>
<li>线性渐变      （gradient）</li>
<li>旋转            （transform）</li>
<li>缩放,定位,倾斜,动画,多背景</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/07/web-frontend-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/07/web-frontend-interview-qa/" class="post-title-link" itemprop="url">前端面试题汇总(Fontend)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-07 13:06:00" itemprop="dateCreated datePublished" datetime="2021-03-07T13:06:00+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 08:23:28" itemprop="dateModified" datetime="2021-03-30T08:23:28+08:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http-1-1-2-0-新增加的功能"><a href="#http-1-1-2-0-新增加的功能" class="headerlink" title="http 1.1/2.0 新增加的功能"></a>http 1.1/2.0 新增加的功能</h1><p><strong>HTTP1.1</strong></p>
<ol>
<li><strong>缓存处理</strong>，在 HTTP1.0 中主要使用 header 来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 并且支持断点续传。</li>
<li><strong>错误通知的管理</strong>，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>
<li>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应. (Connection： keep-alive)</li>
</ol>
<p><strong>HTTP2.0</strong> 大幅度的提高了 web 性能，进一步减少了网络的延迟。实现低延迟高吞吐量。</p>
<ol>
<li>二进制分帧 （二进制格式编码）</li>
<li>首部压缩 （header）</li>
<li>多路复用 （HTTP2.0 可以在共享 TCP 连接的基础上同时发送请求和响应，避免 HTTP 旧版本的队头阻塞问题）</li>
<li>请求优先级</li>
<li>服务器推送 （服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。）</li>
</ol>
<h1 id="用户输入-URL-到浏览器显现给用户页面经过了什么过程"><a href="#用户输入-URL-到浏览器显现给用户页面经过了什么过程" class="headerlink" title="用户输入 URL 到浏览器显现给用户页面经过了什么过程"></a>用户输入 URL 到浏览器显现给用户页面经过了什么过程</h1><ol>
<li>用户输入 URL，浏览器获取到 URL</li>
<li>检查缓存，如果有有效缓存，直接加载</li>
<li>浏览器(应用层)进行 DNS 解析（直接输入 IP 地址既跳过该步骤）</li>
<li>根据解析出的 IP 地址+端口，浏览器（应用层）发起 HTTP 请求</li>
<li>请求到达传输层，tcp 协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。</li>
<li>服务器端收到发送方的 HTTP 请求之后，进行请求文件资源（如 HTML 页面）的寻找并响应报文</li>
<li>客户端收到返回内容后，处理 html</li>
<li>解析 html，生成 dom 树</li>
<li>CSS 解析，为 DOM 中元素加入样式</li>
<li>javascript 解析处理，更改 dom 树</li>
<li>进行页面渲染</li>
<li>重排、重绘</li>
</ol>
<h1 id="HTML5-的新特性"><a href="#HTML5-的新特性" class="headerlink" title="HTML5 的新特性"></a>HTML5 的新特性</h1><ol>
<li>新的内容标签：header nav content footer article 1. aside</li>
<li>更好的单元格体系:</li>
<li>音频、视频 API:video radio</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>网页存储(Web storage) 1. API:localStorage,sessionStorage</li>
<li>拖拽释放(Drag and drop) API</li>
</ol>
<h1 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h1><p>主要分成两部分：渲染引擎(layout engine 或 Rendering Engine)和 JS 引擎。</p>
<ol>
<li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li>
<li>JS 引擎则：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li>
</ol>
<h1 id="cookies，sessionStorage-和-localStorage"><a href="#cookies，sessionStorage-和-localStorage" class="headerlink" title="cookies，sessionStorage 和 localStorage"></a>cookies，sessionStorage 和 localStorage</h1><p>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</p>
<p>存储大小：<br>cookie 数据大小不能超过 4k。<br>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</p>
<p>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h1 id="如何实现浏览器内多个标签页之间的通"><a href="#如何实现浏览器内多个标签页之间的通" class="headerlink" title="如何实现浏览器内多个标签页之间的通"></a>如何实现浏览器内多个标签页之间的通</h1><p>WebSocket、SharedWorker；也可以调用 localstorge、cookies 等本地存储方式；</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/article/271528/">https://www.imooc.com/article/271528/</a></li>
</ul>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><br><br><br><br><br></h1></blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/02/javascript-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/javascript-interview-qa/" class="post-title-link" itemprop="url">javascript 面试题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-02 14:06:00" itemprop="dateCreated datePublished" datetime="2021-03-02T14:06:00+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-14 11:59:04" itemprop="dateModified" datetime="2021-04-14T11:59:04+08:00">2021-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-this-%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9">1. this 都可以是哪些内容</a></li>
<li><a href="#2-%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype">2. 原型链, prototype</a></li>
<li><a href="#3-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">3. new 操作符都做了什么</a></li>
<li><a href="#4-javascript-%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">4. Javascript 的内存回收机制</a></li>
<li><a href="#5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0">5. 内存泄漏的主要原因</a></li>
<li><a href="#6-javascript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">6. Javascript 性能优化</a></li>
<li><a href="#7--vs-">7. === VS ==</a></li>
<li><a href="#8-%E9%97%AD%E5%8C%85">8. 闭包</a></li>
<li><a href="#9-js-%E9%87%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84">9. js 里的作用域是什么样子的？</a></li>
<li><a href="#10-let-%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB">10. let 和 var 的区别</a></li>
<li><a href="#11-%E5%AF%B9-async-%E5%92%8C-await-%E7%9A%84%E7%90%86%E8%A7%A3">11. 对 async 和 await 的理解</a></li>
<li><a href="#12-promised-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81">12. promised 的三种状态</a></li>
<li><a href="#13-asyncawait-%E7%9A%84%E4%BC%98%E7%82%B9">13. async/await 的优点</a></li>
<li><a href="#14-asyncawait-%E7%9A%84%E5%86%99%E6%B3%95">14. async/await 的写法</a></li>
<li><a href="#15-applycall-%E5%92%8C-bind-%E7%9A%84%E5%8C%BA%E5%88%AB">15. apply、call 和 bind 的区别</a></li>
<li><a href="#16-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86">16. 深拷贝的原理</a></li>
<li><a href="#17-set-%E5%92%8C-map-%E7%9A%84%E5%8C%BA%E5%88%AB">17. set 和 Map 的区别</a></li>
<li><a href="#18-js-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-vueangular-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">18. JS 实现双向绑定 （vue/angular 双向绑定的原理）</a></li>
<li><a href="#19-var-%E5%92%8C-let-%E7%9A%84%E5%8C%BA%E5%88%AB">19. var 和 let 的区别</a></li>
<li><a href="#20-javascript-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">20. Javascript 如何实现继承？</a></li>
<li><a href="#21-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">21. 变量提升</a></li>
<li><a href="#22-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">22. 变量提升</a></li>
<li><a href="#23-%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">23. 函数提升</a></li>
<li><a href="#24-%E4%BD%9C%E7%94%A8%E5%9F%9F">24. 作用域</a></li>
<li><a href="#25-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%8B%E5%BA%8F">25. 实现一个随机排序的程序</a></li>
<li><a href="#26-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E4%BD%BF%E7%94%A8%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E6%95%B0%E9%87%8F">26. 实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量</a></li>
<li><a href="#27-%E5%8F%82%E8%80%83">27. 参考</a></li>
</ul>
<h1 id="1-this-都可以是哪些内容"><a href="#1-this-都可以是哪些内容" class="headerlink" title="1. this 都可以是哪些内容"></a>1. this 都可以是哪些内容</h1><p>对 C#、Java 等语言，this 就是当前对象，但是 javascript 不是，简单来说：</p>
<ul>
<li>全局 this 是 window;</li>
<li>函数 this 是调用者;</li>
<li>构造函数的 this 是 new 之后的新对象,</li>
<li>call 和 apply bind 的 this 第一个参数</li>
</ul>
<h1 id="2-原型链-prototype"><a href="#2-原型链-prototype" class="headerlink" title="2. 原型链, prototype"></a>2. 原型链, prototype</h1><ul>
<li>函数对象都包含 prototype 属性（函数的原型对象），其作用就是让该函数所实例化的对象们都可以找到公用的属性和方法；</li>
<li>constructor 属性的含义就是指向该对象的构造函数</li>
<li><code>__proto__</code>和 constructor 属性是对象所独有的；prototype 属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和 constructor 属性。</li>
<li>JavaScript 的每个对象都继承另一个父级对象，父级对象称为原型 (prototype) 对象。</li>
<li>每一个实例对象都有一个私有属性<strong>proto</strong>指向其构造函数的原型对象 prototype；该原型对象也会作为实例对象有一个私有属性<strong>proto</strong>，层层向上直到一个对象的原型对象值为 null。</li>
<li>当访问一个对象的属性或方法时，js 引擎会先查找该对象本身是否包含，如果没有，会去该对象的<strong>proto</strong>属性所指向的原型对象上找，如果没有，会继续向上一层找，直到某个对象的<strong>proto</strong>值为 null,这就是原型链。</li>
<li>每个构造函数都有一个 prototype 属性，指向另外一个对象，说明整个对象所有的属性和方法都会被构造函数所拥有。</li>
</ul>
<h1 id="3-new-操作符都做了什么"><a href="#3-new-操作符都做了什么" class="headerlink" title="3. new 操作符都做了什么"></a>3. new 操作符都做了什么</h1><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p>
<p>new Object()举例:</p>
<ol>
<li>创建一个新对象</li>
<li>把新对象的原型指向构造函数的 prototype</li>
<li>把构造函数里的 this 指向新对象</li>
<li>返回这个新对象</li>
</ol>
<h1 id="4-Javascript-的内存回收机制"><a href="#4-Javascript-的内存回收机制" class="headerlink" title="4. Javascript 的内存回收机制"></a>4. Javascript 的内存回收机制</h1><p>Javascript 内嵌了垃圾收集器，用来跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。垃圾收集器会按照固定的时间间隔，或代码执行中预定的收集时间，周期性地执行这一操作。<br>垃圾收集器必须跟踪哪个变量有用哪个变量无用，对于不再有用的变量打上标记，以备将来收回其所占用的内存。用于标识无用变量的策略通常有标记清除和引用计数两种。不同浏览器采用的策略不完全一致。</p>
<h1 id="5-内存泄漏的主要原因"><a href="#5-内存泄漏的主要原因" class="headerlink" title="5. 内存泄漏的主要原因"></a>5. 内存泄漏的主要原因</h1><ul>
<li>缓存</li>
<li>队列消费不及时</li>
<li>作用域未释放</li>
</ul>
<h1 id="6-Javascript-性能优化"><a href="#6-Javascript-性能优化" class="headerlink" title="6. Javascript 性能优化"></a>6. Javascript 性能优化</h1><ol>
<li>针对 js 方面的前端性能优化，可以 1）使用 ansyc/defer 加载；2）加载时，放到<code>&lt;/body&gt;</code>之前；3) 合并 JS 文件，并进行最小化处理；4）缓存；5）使用 CDN 网络；6）js 的 HTTP 压缩</li>
<li>删除未使用的功能性代码以及与之相关的代码， 多余的依赖库，被滥用的 npm 包。</li>
<li>减少作用域链上的查找次数（减少循环中的活动）。比如 for 循环，把 Array.length 赋值给一个变量，而不是每次比较都直接使用 length 属性；对页面元素进行操作时，取出复制给一个变量，每次操作都对这个变量进行操作，而不是每次操作都再重复取一下这个元素；</li>
<li>闭包导致的内存泄露。闭包可以保证函数内的变量安全，可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会被自动清除。我们需要手动销毁内存中的变量。（赋值为 null）；</li>
<li>尽量少用全局变量，尽量使用局部变量。</li>
<li>减少不必要的变量</li>
<li>类型转换：把数字转换成字符串使用 number + “” 。 性能对比： (“” + ) &gt; String() &gt; .toString() &gt; new String()</li>
<li>对字符串进行循环操作，譬如替换、查找，应使用正则表达式。因为本身 JavaScript 的循环速度就比较慢，而正则表达式的操作是用 C 写成的语言的 API，性能很好。</li>
<li>浮点数转换成整型使用 Math.floor()或者 Math.round()。parseInt()是用于将字符串转换成数字，Math 是内部对象，所以 Math.floor()其实并没有多少查询方法和调用的时间，速度是最快的。</li>
<li>使用 classname 代替大量的内联样式修改。</li>
<li>循环遍历，尽量少用 for in， 虽然代码易读，但性能很差。 尤其是遍历属性数量未知的情况下，少用。</li>
</ol>
<h1 id="7-VS"><a href="#7-VS" class="headerlink" title="7. === VS =="></a>7. === VS ==</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">&quot;100&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&quot;&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&quot;&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>很有意思吧， 看看这两个，是等效的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj == <span class="literal">null</span>;</span><br><span class="line">obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h1 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8. 闭包"></a>8. 闭包</h1><p>在 JavaScript 中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure)。这得益于高阶函数的特性：函数可以作为参数或者者返回值；</p>
<p><strong>当一个内部函数被调用，就会形成闭包</strong>，闭包就是能够读取其他函数内部变量的函数，就是一个函数去访问了另外一个函数的中的变量的函数。</p>
<p><strong>闭包作用</strong>：局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。延伸变量的作用范围。</p>
<p><strong>闭包特点</strong>：占用更多内存；不容易被释放</p>
<p><strong>闭包用法</strong>：变量既想反复使用，又想避免全局污染如何使用？</p>
<ol>
<li>定义外层函数，封装被保护的局部变量。</li>
<li>定义内层函数，执行对外部函数变量的操作。</li>
<li>外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。</li>
</ol>
<p>e.g.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> innerMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  innerMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-js-里的作用域是什么样子的？"><a href="#9-js-里的作用域是什么样子的？" class="headerlink" title="9. js 里的作用域是什么样子的？"></a>9. js 里的作用域是什么样子的？</h1><p>大多数语言里边都是块作作用域，以{}进行限定，js 里边不是．js 里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量 p1 在函数最后一行定义，第一行也有效，但是值是 undefined.</p>
<h1 id="10-let-和-var-的区别"><a href="#10-let-和-var-的区别" class="headerlink" title="10. let 和 var 的区别"></a>10. let 和 var 的区别</h1><ul>
<li>var 声明变量可以重复声明，而 let 不可以重复声明，属于 TDZ 暂时性死区问题</li>
<li>作用域不同，var 是函数作用域，而 let 是块级作用域；</li>
<li>var 可以在声明的上面访问变量，而 let 不存在变量提升；</li>
</ul>
<h1 id="11-对-async-和-await-的理解"><a href="#11-对-async-和-await-的理解" class="headerlink" title="11. 对 async 和 await 的理解"></a>11. 对 async 和 await 的理解</h1><ol>
<li>async…await 是基于 promise 的 generator 语法糖，是用来解决异步的，它用来等待 promise 的执行结果，常规函数使用 await 没有效果；</li>
<li>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</li>
<li>当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句；</li>
</ol>
<h1 id="12-promised-的三种状态"><a href="#12-promised-的三种状态" class="headerlink" title="12. promised 的三种状态"></a>12. promised 的三种状态</h1><p>promise 有三种状态：pending/reslove/reject 。pending 就是未决，resolve 可以理解为成功，reject 可以理解为拒绝。</p>
<h1 id="13-async-await-的优点"><a href="#13-async-await-的优点" class="headerlink" title="13. async/await 的优点"></a>13. async/await 的优点</h1><p><strong>1）方便级联调用：</strong> 即调用依次发生的场景；</p>
<p><strong>2）同步代码编写方式：</strong> Promise 使用 then 函数进行链式调用，一直点点点，是一种从左向右的横向写法；async/await 从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯；</p>
<p><strong>3）多个参数传递：</strong> Promise 的 then 函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦；async/await 没有这个限制，可以当做普通的局部变量来处理，用 let 或者 const 定义的块级变量想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余工作；</p>
<p><strong>4）同步代码和异步代码可以一起编写：</strong> 使用 Promise 的时候最好将同步代码和异步代码放在不同的 then 节点中，这样结构更加清晰；async/await 整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个 Promise 对象放在 await 关键字后面；</p>
<p><strong>5）基于协程：</strong> Promise 是根据函数式编程的范式，对异步过程进行了一层封装，async/await 基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</p>
<p><strong>6）async/await 是对 Promise 的优化：</strong> async/await 是基于 Promise 的，是进一步的一种优化，不过在写代码时，Promise 本身的 API 出现得很少，很接近同步代码的写法；</p>
<h1 id="14-async-await-的写法"><a href="#14-async-await-的写法" class="headerlink" title="14. async/await 的写法"></a>14. async/await 的写法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">await</span> testAsync();</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-apply、call-和-bind-的区别"><a href="#15-apply、call-和-bind-的区别" class="headerlink" title="15. apply、call 和 bind 的区别"></a>15. apply、call 和 bind 的区别</h1><p>这三者都是用来改变函数的 this 对象的指向的(也就是说要改变函数运行时的 context 即上下文),第一个参数都是 this 要指向的对象。</p>
<p>不同之处：</p>
<ol>
<li>call 接受连续参数，apply 接受数组参数。</li>
<li>bind 功能和 call apply 差不多，区别在于 bind 返回的是一个改变 this 指向的新函数，这个函数不是立即执行函数（call apply 两个立即执行！）</li>
</ol>
<h1 id="16-深拷贝的原理"><a href="#16-深拷贝的原理" class="headerlink" title="16. 深拷贝的原理"></a>16. 深拷贝的原理</h1><p>操作的是值，取出对象的值，放到一个新的{}，修改时不会影响到原数据；要完成对象的深拷贝需要使用递归遍历所有对象的属性进行赋值，也可以使用 JSON.stringfy 和 JSON.parse 操作。</p>
<h1 id="17-set-和-Map-的区别"><a href="#17-set-和-Map-的区别" class="headerlink" title="17. set 和 Map 的区别"></a>17. set 和 Map 的区别</h1><ol>
<li>Set 是一种类似数组的集合类型，它与数组不同的是，不允许存在重复数据；常用操作方法有：add,delete,has,clear 等；遍历使用 forEach；</li>
<li>Map 是一种类似对象的集合类型，它与对象不同的是，key 可以接受对象类型，常用的操作方法有：set,get,has,delete 等；遍历使用 forEach</li>
</ol>
<h1 id="18-JS-实现双向绑定-（vue-angular-双向绑定的原理）"><a href="#18-JS-实现双向绑定-（vue-angular-双向绑定的原理）" class="headerlink" title="18. JS 实现双向绑定 （vue/angular 双向绑定的原理）"></a>18. JS 实现双向绑定 （vue/angular 双向绑定的原理）</h1><p><strong>vue.js</strong> 采用数据劫持（Proxy 模式）结合发布者-订阅者模式（PubSub 模式）的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>Object.defineProperty( )内还包含一对儿 getter 和 setter 函数，它们被称作这个对象的访问器属性，这两个函数都不是必须的，只是在读取访问对象属性时，会调用 getter 函数，这个函数负责返回有效值，在写入对象属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。</p>
<p><strong>Angular</strong>, 采用脏检查的方式。基于 zone.js，重写 setTimeout, httpRequest 等方法，触发脏检查, 更新 dom 节点。</p>
<h1 id="19-var-和-let-的区别"><a href="#19-var-和-let-的区别" class="headerlink" title="19. var 和 let 的区别"></a>19. var 和 let 的区别</h1><ol>
<li>作用域不同， var 是函数作用域，let 是块作用域。</li>
</ol>
<ul>
<li>在函数中声明了 var，整个函数内都是有效的，比如说在 for 循环内定义的一个 var 变量，实际上其在 for 循环以外也是可以访问的</li>
<li>而 let 由于是块作用域，所以如果在块作用域内定义的变量，比如说在 for 循环内，在其外面是不可被访问的，所以 for 循环推荐用 let</li>
</ul>
<ol start="2">
<li>let 不能在定义之前访问该变量，但是 var 可以。 （var 可以提升变量作用域）</li>
<li>let不能被重新定义，但是var是可以的。（重新定义var，执行时会忽略）<h1 id="20-Javascript-如何实现继承？"><a href="#20-Javascript-如何实现继承？" class="headerlink" title="20. Javascript 如何实现继承？"></a>20. Javascript 如何实现继承？</h1></li>
</ol>
<p>1、构造继承<br>2、原型继承: Child.prototype = new Parent();<br>3、实例继承<br>4、拷贝继承</p>
<h1 id="21-变量提升"><a href="#21-变量提升" class="headerlink" title="21. 变量提升"></a>21. 变量提升</h1><p>js 引擎首先在读取 js 代码时默认执行 2 个步骤：</p>
<ol>
<li>解释(通篇扫描所有 js 代码，然后把所有声明(变量申明、函数声明)提升到对应作用域顶端)</li>
<li>执行(执行逻辑操作)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 ReferenceError: b is not defined</span></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<h1 id="22-变量提升"><a href="#22-变量提升" class="headerlink" title="22. 变量提升"></a>22. 变量提升</h1><p>js 引擎首先在读取 js 代码时默认执行 2 个步骤：</p>
<ol>
<li>解释(通篇扫描所有 js 代码，然后把所有声明(变量申明、函数声明)提升到对应作用域顶端)</li>
<li>执行(执行逻辑操作)</li>
</ol>
<h1 id="23-函数提升"><a href="#23-函数提升" class="headerlink" title="23. 函数提升"></a>23. 函数提升</h1><p>首先要知道函数定义有两种方式的，一种是函数定义表达式，一种是函数声明语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提升测试</span></span><br><span class="line"><span class="comment">// 例1.</span></span><br><span class="line">f();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2.</span></span><br><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 Uncaught TypeError: f is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="comment">//  [Function: f]</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例4</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 输出：10</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：1</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>重点：</p>
<ol>
<li>函数提升针对是函数声明语句而言，其次变量提升只提升变量名而函数提升会提升整个函数体</li>
<li>优先级，函数提升会在变量提升的上面</li>
</ol>
<h1 id="24-作用域"><a href="#24-作用域" class="headerlink" title="24. 作用域"></a>24. 作用域</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1 块级作用域, 不适合变量提升</span></span><br><span class="line"><span class="comment">// es6允许块级作用域的任意嵌套。外层作用域无法读取内层作用域的变量。</span></span><br><span class="line"><span class="comment">// 内层作用域可以定义外层作用域的同名变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> z = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(v, z);</span><br><span class="line"><span class="comment">//输出 :</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2 闭包，变量提升</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//输出 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例 3， 块级作用域内let和const命令所声明的变量，只在命令所在的代码块内有效。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例4 let， var与作用域、变量提升</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="25-实现一个随机排序的程序"><a href="#25-实现一个随机排序的程序" class="headerlink" title="25. 实现一个随机排序的程序"></a>25. 实现一个随机排序的程序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">list.sort(randomSort);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after random sort: &quot;</span>, list.join(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line">list.sort(<span class="function">() =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after random sort: &quot;</span>, list.join(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="26-实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量"><a href="#26-实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量" class="headerlink" title="26. 实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量"></a>26. 实现一个函数，传入一个字符串，得到使用次数最多的字符，以及数量</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMostUsedChar</span>(<span class="params">sourceString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = sourceString.length;</span><br><span class="line">  <span class="keyword">let</span> counter = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentChar = sourceString[i];</span><br><span class="line">    <span class="keyword">if</span> (counter[currentChar]) &#123;</span><br><span class="line">      counter[currentChar]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      counter[currentChar] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> maxCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxChar = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter[key] &gt;= maxCount) &#123;</span><br><span class="line">      maxChar = key;</span><br><span class="line">      maxCount = counter[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`most used char: <span class="subst">$&#123;maxChar&#125;</span>, count: <span class="subst">$&#123;maxCount&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMostUsedChar(<span class="string">&quot;fjiwejfal33232jkj3fjfie&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="27-参考"><a href="#27-参考" class="headerlink" title="27. 参考"></a>27. 参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md">https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md</a></li>
</ul>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><br><br><br><br><br></h1></blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/02/node-js-interview-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/node-js-interview-qa/" class="post-title-link" itemprop="url">node.js 面试题总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-02 14:06:00" itemprop="dateCreated datePublished" datetime="2021-03-02T14:06:00+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 08:23:41" itemprop="dateModified" datetime="2021-03-30T08:23:41+08:00">2021-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-nodejs-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9">1. nodejs 有哪些特点？</a></li>
<li><a href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-event-loop">2. 什么是事件循环 Event Loop</a></li>
<li><a href="#3-%E5%9C%A8%E6%AF%8F%E4%B8%AA-tick-%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%91%A2">3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？</a></li>
<li><a href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">4. 什么是回调函数？</a></li>
<li><a href="#5-nodejs-%E8%AE%A1%E6%97%B6%E5%99%A8-promisethenprocessnexttick-settimeoutsetimmediate-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序</a></li>
<li><a href="#6-next-tick-%E5%92%8C-setimmediate-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">6. next tick 和 setImmediate 的区别是什么？</a></li>
<li><a href="#7-nodejs-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">7. node.js 模块加载机制</a></li>
<li><a href="#8-%E4%BB%80%E4%B9%88%E6%98%AF-globals">8. 什么是 globals?</a></li>
<li><a href="#9-%E4%BB%80%E4%B9%88%E6%98%AF-eventemitter">9. 什么是 EventEmitter?</a></li>
<li><a href="#10-process-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">10. process 有哪些常用方法?</a></li>
<li><a href="#11-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF-reactor-pattern">11. 解释一下什么是 reactor pattern。</a></li>
<li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%99%E8%AF%AF%E4%BC%98%E5%85%88%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">12. 什么是错误优先的回调函数</a></li>
<li><a href="#13-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">13. 如何避免回调地狱</a></li>
<li><a href="#14-%E4%BB%80%E4%B9%88%E6%98%AF-promise">14. 什么是 Promise?</a></li>
<li><a href="#15-%E4%BD%BF%E7%94%A8-npm-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84">15. 使用 NPM 有哪些好处？</a></li>
<li><a href="#16-%E4%BB%80%E4%B9%88%E6%98%AF-stub">16. 什么是 Stub？</a></li>
<li><a href="#17-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94">17. 什么是测试金字塔？</a></li>
<li><a href="#18-node-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6">18. Node 模块机制</a></li>
<li><a href="#19-nodejs-require-%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">19. Node.js require 的模块加载机制</a></li>
<li><a href="#20-v8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">20. V8 的垃圾回收机制</a></li>
<li><a href="#21-child-process">21. child-process</a></li>
<li><a href="#22-%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB">22. 创建子进程的方法有哪些，简单说一下它们的区别</a></li>
<li><a href="#23-%E6%80%8E%E6%A0%B7%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA-cpu">23. 怎样充分利用多个 CPU?</a></li>
<li><a href="#24-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%A9-node-%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%90%8E%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF">24. 有哪些方法可以让 node 程序遇到错误后自动重启?</a></li>
<li><a href="#25-%E5%85%B3%E4%BA%8E-express-%E6%A1%86%E6%9E%B6">25. 关于 Express 框架</a><ul>
<li><a href="#251-express-%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">25.1. express 生成器的作用是什么?</a></li>
<li><a href="#252-express-%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">25.2. express 优点是什么?</a></li>
<li><a href="#253-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BB%B6">25.3. 什么是中间件</a></li>
<li><a href="#254-express-%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">25.4. express 缺点是什么?</a></li>
<li><a href="#255-ejs-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">25.5. ejs 作用是什么?</a></li>
<li><a href="#256-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E9%A1%B9%E7%9B%AE">25.6. 什么是后端渲染项目?</a></li>
<li><a href="#257-session-%E5%92%8C-cookie-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB">25.7. session 和 cookie 的作用和区别?</a></li>
<li><a href="#258-%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F">25.8. 跨域是什么, 如何解决跨域?</a></li>
<li><a href="#259-express4-%E4%B8%AD-app-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">25.9. express4 中 app 和 router 的区别</a></li>
<li><a href="#2510-cookies-%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">25.10. Cookies 如何防范 XSS 攻击？</a></li>
<li><a href="#2511-koa-%E5%92%8C-express-%E7%9A%84%E5%AF%B9%E6%AF%94">25.11. Koa 和 Express 的对比</a></li>
</ul>
</li>
<li><a href="#26-koa">26. KOA</a><ul>
<li><a href="#261-koa-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B">26.1. KOA 洋葱模型</a></li>
</ul>
</li>
</ul>
<h1 id="1-nodejs-有哪些特点？"><a href="#1-nodejs-有哪些特点？" class="headerlink" title="1. nodejs 有哪些特点？"></a>1. nodejs 有哪些特点？</h1><p>是单线程的，但是有很高的可扩展性，使用 JavaScript 作为主流编程语言。使用的是<code>非阻塞IO,异步处理机制和事件驱动</code>。处理高效。</p>
<p>擅长 IO 密集型业务业务处理，不擅长 CPU 密集型业务；</p>
<h1 id="2-什么是事件循环-Event-Loop"><a href="#2-什么是事件循环-Event-Loop" class="headerlink" title="2. 什么是事件循环 Event Loop"></a>2. 什么是事件循环 Event Loop</h1><p>在进程启动动时，Node 会创建一个类似于 while(true)的循环，每执行一次循环的过程我们称之为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有，就取出时间相关的回调函数。如果存在相关联的回调函数，就执行它们。然后进入下一个循环；如果不再有事件待处理，就退出进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I&#x2F;O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>

<ol>
<li>timers: 这个阶段执行 setTimeout()和 setInterval()设定的回调。</li>
<li>I/O callbacks: 执行几乎所有的回调，除了 close 回调，timer 的回调，和 setImmediate()的回调。</li>
<li>idle, prepare: 仅内部使用。</li>
<li>poll: 获取新的 I/O 事件；node 会在适当条件下阻塞在这里。</li>
<li>check: 执行 setImmediate()设定的回调。</li>
<li>close callbacks: 执行比如 socket.on(‘close’, …)的回调。</li>
</ol>
<p>简单理解 Event Loop 如下：</p>
<ol>
<li>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)</li>
<li>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务</li>
<li>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p>在底层， Node 是通过 libuv 来实现多线程的。<code>Libuv</code>库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环， 以异步的方式将任务的执行结果返回给 V8 引擎。可</p>
<h1 id="3-在每个-tick-的过程中，如何判断是否有事件需要处理呢？"><a href="#3-在每个-tick-的过程中，如何判断是否有事件需要处理呢？" class="headerlink" title="3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？"></a>3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？</h1><ol>
<li>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</li>
<li>在 Node 中，事件主要来源于网络请求、文件的 I/O 等，这些事件对应的观察者有文件 I/O 观察者，网络 I/O 的观察者。</li>
<li>事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</li>
</ol>
<h1 id="4-什么是回调函数？"><a href="#4-什么是回调函数？" class="headerlink" title="4. 什么是回调函数？"></a>4. 什么是回调函数？</h1><p>回调函数是指用一个函数作为参数传入另一个函数，这个函数会被在某个时机调用。</p>
<h1 id="5-node-js-计时器-promise-then-process-nextTick-setTimeout，setImmediate-执行顺序"><a href="#5-node-js-计时器-promise-then-process-nextTick-setTimeout，setImmediate-执行顺序" class="headerlink" title="5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序"></a>5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序</h1><p>首先了解 2 个概念</p>
<ul>
<li>macro-task（宏任务）: script ，setTimeout, setInterval, setImmediate, I/O, UI rendering.Event Loop 在每个阶段执行的任务；</li>
<li>micro-task （微任务）: process.nextTick, Promise，Object. fvEvent Loop 在每个阶段之间执行的任务 observe，MutationObserver</li>
</ul>
<p>对于 node.js, micro-task 的任务优先级高于 macro-task 的任务优先级,所以微任务普遍优先于宏任务的执行。</p>
<p>另一种优先级顺序，是“观察者优先级”， 在每次轮训检查中，各观察者的优先级分别是：<code>idle观察者 &gt; I/O观察者 &gt; check观察者。</code></p>
<ul>
<li>idle 观察者：process.nextTick</li>
<li>I/O 观察者：一般性的 I/O 回调，如网络，文件，数据库 I/O 等</li>
<li>check 观察者：setTimeout &gt; setImmediate (setTimeout(()=&gt;{},0)优先于 setImmediate 执行）；</li>
<li><strong>总结</strong></li>
</ul>
<ol>
<li>同步代码执行顺序优先级高于异步代码执行顺序优先级；</li>
<li>new Promise(fn)中的 fn 是同步执行；</li>
<li>process.nextTick()&gt;Promise.then()&gt;setTimeout&gt;setImmediate。</li>
</ol>
<h1 id="6-next-tick-和-setImmediate-的区别是什么？"><a href="#6-next-tick-和-setImmediate-的区别是什么？" class="headerlink" title="6. next tick 和 setImmediate 的区别是什么？"></a>6. next tick 和 setImmediate 的区别是什么？</h1><ul>
<li><p>NextTick 会等待当前的 event 执行完成或者下一轮儿事件循环到达再执行。</p>
</li>
<li><p>SetImmediate, 会在下一轮的事件循环中，执行回调并且返回当前的循环来做读写操作.</p>
</li>
</ul>
<h1 id="7-node-js-模块加载机制"><a href="#7-node-js-模块加载机制" class="headerlink" title="7. node.js 模块加载机制"></a>7. node.js 模块加载机制</h1><p>Nodejs 遵循 commonjs 规范的模块加载机制，使用 require 加载文件，使用 exports 或 module.exports 导出文件</p>
<h1 id="8-什么是-globals"><a href="#8-什么是-globals" class="headerlink" title="8. 什么是 globals?"></a>8. 什么是 globals?</h1><p>有三个 global 的关键字。</p>
<ol>
<li>Global 代表的是最上层的命名空间,用来管理所有其他的全局对象。</li>
<li>Process 是一个全局对象，可以把异步函数转化成异步回调, 它可以在任何地方被访问，它主要是用来返回系统的应用信息和环境信息.</li>
<li>Buffer, 是用来处理二进制数据的类.</li>
</ol>
<h1 id="9-什么是-EventEmitter"><a href="#9-什么是-EventEmitter" class="headerlink" title="9. 什么是 EventEmitter?"></a>9. 什么是 EventEmitter?</h1><p>EventEmitter 是 node 中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题.</p>
<p>主要用于： 1) 模块间传递消息 2) 回调函数内外传递消息 3) 处理流数据，因为流是在 EventEmitter 基础上实现的. 4) 观察者模式发射触发机制相关应用</p>
<h1 id="10-process-有哪些常用方法"><a href="#10-process-有哪些常用方法" class="headerlink" title="10. process 有哪些常用方法?"></a>10. process 有哪些常用方法?</h1><p>process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>
<h1 id="11-解释一下什么是-reactor-pattern。"><a href="#11-解释一下什么是-reactor-pattern。" class="headerlink" title="11. 解释一下什么是 reactor pattern。"></a>11. 解释一下什么是 reactor pattern。</h1><p>reactor 设计模式是 event-driven architecture 的一种实现方式，处理多个客户端并发的向服务端请求服务的场景。每种服务在服务端可能由多个方法组成。reactor 会解耦并发请求的服务并分发给对应的事件处理器来处理。</p>
<p>Reactor pattern 主要是非阻滞的 i/o 操作。提供一个回调函数来关联 io 操作。io 请求完成以后会不会提交给 demultiplexer, 这是一个通知接口用来处理并发性的非阻滞的 io 操作，这个功能是通过查询一个 event loop 来实现的.</p>
<h1 id="12-什么是错误优先的回调函数"><a href="#12-什么是错误优先的回调函数" class="headerlink" title="12. 什么是错误优先的回调函数"></a>12. 什么是错误优先的回调函数</h1><p>node.js 广泛使用异步编程，而异步中的异常很难在主程序中捕获。为此，我们将异步中的异常、错误，通过回调函数传递给主程序。</p>
<p>错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。</p>
<h1 id="13-如何避免回调地狱"><a href="#13-如何避免回调地狱" class="headerlink" title="13. 如何避免回调地狱"></a>13. 如何避免回调地狱</h1><ol>
<li>模块化：将回调函数分割为独立的函数</li>
<li>使用 Promise/ansyc (ES6)</li>
<li>使用 yield 来计算生成器或 Promise</li>
</ol>
<h1 id="14-什么是-Promise"><a href="#14-什么是-Promise" class="headerlink" title="14. 什么是 Promise?"></a>14. 什么是 Promise?</h1><p>Promise 可以帮助我们更好地处理异步操作。采用类似同步结构的代码，实现异步处理，同时避免回调地狱。</p>
<h1 id="15-使用-NPM-有哪些好处？"><a href="#15-使用-NPM-有哪些好处？" class="headerlink" title="15. 使用 NPM 有哪些好处？"></a>15. 使用 NPM 有哪些好处？</h1><p>通过 NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于 Node 应用开发而言，你可以通过 package.json 文件来管理项目信息，配置脚本， 以及指明项目依赖的具体版本。</p>
<h1 id="16-什么是-Stub？"><a href="#16-什么是-Stub？" class="headerlink" title="16. 什么是 Stub？"></a>16. 什么是 Stub？</h1><p>Stub 是用于模拟一个组件或模块的函数或程序，在测试用例中很常用。简单的说，你可以用 Stub 去模拟一个方法，从而避免调用真实的方法， 使用 Stub 你还可以返回虚构的结果。你可以配合断言使用 Stub。</p>
<h1 id="17-什么是测试金字塔？"><a href="#17-什么是测试金字塔？" class="headerlink" title="17. 什么是测试金字塔？"></a>17. 什么是测试金字塔？</h1><p>测试金字塔指的是： 测试用例从下到上，包括单元测试、集成测试、端到端测试；当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。</p>
<h1 id="18-Node-模块机制"><a href="#18-Node-模块机制" class="headerlink" title="18. Node 模块机制"></a>18. Node 模块机制</h1><p>Node 中，每个文件模块都是一个对象，所有的模块都是 Module 的实例。</p>
<h1 id="19-Node-js-require-的模块加载机制"><a href="#19-Node-js-require-的模块加载机制" class="headerlink" title="19. Node.js require 的模块加载机制"></a>19. Node.js require 的模块加载机制</h1><p>1、先计算模块路径<br>2、如果模块在缓存里面，取出缓存；如果不存在生成模块实例，存入缓存<br>3、加载模块<br>4、输出模块的 exports 属性</p>
<h1 id="20-V8-的垃圾回收机制"><a href="#20-V8-的垃圾回收机制" class="headerlink" title="20. V8 的垃圾回收机制"></a>20. V8 的垃圾回收机制</h1><p>在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。<br><strong>新生代</strong>中的对象主要通过 Scavenge 算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一份为二，分为 2 个 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。</p>
<ol>
<li>当开始垃圾回收的时候，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间发生角色对换。</li>
<li>应为新生代中对象的生命周期比较短，就比较适合这个算法。</li>
<li>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。<br><strong>老生代</strong>主要采取的是标记清除的垃圾回收算法。与 Scavenge 复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。</li>
</ol>
<p><strong>标记清楚算法的问题</strong>：<br>主要问题是每一次进行标记清除回收后，内存空间会出现不连续的状态</p>
<ol>
<li>这种内存碎片会对后续内存分配造成问题，很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</li>
<li>为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</li>
</ol>
<h1 id="21-child-process"><a href="#21-child-process" class="headerlink" title="21. child-process"></a>21. child-process</h1><p>node 是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统 shell 命令交互，调用可执行文件，创建子进程进行阻塞式访问或高 CPU 计算等，child-process 就是为满足这些需求而生的．child-process 顾名思义，就是把 node 阻塞的工作交给子进程去做．</p>
<h1 id="22-创建子进程的方法有哪些，简单说一下它们的区别"><a href="#22-创建子进程的方法有哪些，简单说一下它们的区别" class="headerlink" title="22. 创建子进程的方法有哪些，简单说一下它们的区别"></a>22. 创建子进程的方法有哪些，简单说一下它们的区别</h1><p>创建子进程的方法大致有：</p>
<ol>
<li>spawn()： 启动一个子进程来执行命令</li>
<li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li>
<li>execFlie(): 启动一个子进程来执行可执行文件</li>
<li>fork(): 与 spawn()类似，不同电在于它创建 Node 子进程需要执行 js 文件</li>
<li>spawn()与 exec()、execFile()不同的是，后两者创建时可以指定 timeout 属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死</li>
<li>exec()与 execFile()不同的是，exec()适合执行已有命令，execFile()适合执行文件。</li>
</ol>
<p>（exec 可以用操作系统原生的方式执行各种命令，如管道 cat ab.txt | grep hello; execFile 是执行一个文件; spawn 是流式和操作系统进行交互; fork 是两个 node 程序(javascript)之间时行交互.）</p>
<h1 id="23-怎样充分利用多个-CPU"><a href="#23-怎样充分利用多个-CPU" class="headerlink" title="23. 怎样充分利用多个 CPU?"></a>23. 怎样充分利用多个 CPU?</h1><p>一个 CPU 运行一个 node 实例。 （Child_Process)</p>
<h1 id="24-有哪些方法可以让-node-程序遇到错误后自动重启"><a href="#24-有哪些方法可以让-node-程序遇到错误后自动重启" class="headerlink" title="24. 有哪些方法可以让 node 程序遇到错误后自动重启?"></a>24. 有哪些方法可以让 node 程序遇到错误后自动重启?</h1><p>Linxu: 1) runit 2) forever 3) nohup npm start &amp;<br>Winwow: Windows service(auto restart)</p>
<h1 id="25-关于-Express-框架"><a href="#25-关于-Express-框架" class="headerlink" title="25. 关于 Express 框架"></a>25. 关于 Express 框架</h1><h2 id="25-1-express-生成器的作用是什么"><a href="#25-1-express-生成器的作用是什么" class="headerlink" title="25.1. express 生成器的作用是什么?"></a>25.1. express 生成器的作用是什么?</h2><p>通过应用生成器工具 express-generator 可以快速创建一个应用的框架, 包含一整套配置好的服务器配置, 文件和文件夹等, 包括静态资源的暴露等, 包括路由的配置, 和模板引擎配置, 以及 404 的处理，异常处理等；</p>
<h2 id="25-2-express-优点是什么"><a href="#25-2-express-优点是什么" class="headerlink" title="25.2. express 优点是什么?"></a>25.2. express 优点是什么?</h2><p>Express 的优点是线性逻辑：路由和中间件完美融合，通过中间件形式把业务逻辑细分，简化，一个请求进来经过一系列中间件处理后再响应给用户，再复杂的业务也是线性了，清晰明了。</p>
<h2 id="25-3-什么是中间件"><a href="#25-3-什么是中间件" class="headerlink" title="25.3. 什么是中间件"></a>25.3. 什么是中间件</h2><ul>
<li>中间件是可以访问请求对象，响应对象以及 next 应用程序请求-响应周期中的函数，使用 app.use()来使用/定义中间件；</li>
<li>Express 是一个自身功能极简，完全是路由和中间件构成一个 web 开发框架；</li>
<li>从本质上来说，一个 Express 应用就是在调用各种中间件。封装了一些或许复杂但肯定是通用的功能, 非内置的中间件需要通过安装后，require 到文件就可以运行。</li>
</ul>
<h2 id="25-4-express-缺点是什么"><a href="#25-4-express-缺点是什么" class="headerlink" title="25.4. express 缺点是什么?"></a>25.4. express 缺点是什么?</h2><p>Express 是基于 callback 来组合业务逻辑。Callback 有两大硬伤，一是<code>不可组合</code>，二是<code>异常不可捕获</code>。</p>
<h2 id="25-5-ejs-作用是什么"><a href="#25-5-ejs-作用是什么" class="headerlink" title="25.5. ejs 作用是什么?"></a>25.5. ejs 作用是什么?</h2><p>EJS 是一个 Javascript 模板库, 用来从 JSON 数据中生成 HTML 文件。其他模板库（模板引擎如 jade/pug);</p>
<h2 id="25-6-什么是后端渲染项目"><a href="#25-6-什么是后端渲染项目" class="headerlink" title="25.6. 什么是后端渲染项目?"></a>25.6. 什么是后端渲染项目?</h2><p>浏览器请求静态网页资源, 服务器端会在后端把数据渲染到 HTML 页面上, 再把 html 文件内的字符串一起返回给浏览器进行展示的一种手段, Nodejs 中体现为 ejs 和 pug 模板引擎；</p>
<h2 id="25-7-session-和-cookie-的作用和区别"><a href="#25-7-session-和-cookie-的作用和区别" class="headerlink" title="25.7. session 和 cookie 的作用和区别?"></a>25.7. session 和 cookie 的作用和区别?</h2><p>session 是区别于数据库存在的一种服务器临时存储技术, 它主要存储一些无需持久化的数据, 比如临时的登录状态信息等</p>
<p>cookie 是存在于浏览器上的一种浏览器本地存储的方式, 同域名下的 cookie 不同标签页可以共享, 默认过期时间是浏览器关闭时, 而且在进行 http 请求时, 会自动带上浏览器全部的 cookie 发给后台, 后台也可以获取 cookie, 设置可以在响应时, 想浏览器中设置 cookie。</p>
<h2 id="25-8-跨域是什么-如何解决跨域"><a href="#25-8-跨域是什么-如何解决跨域" class="headerlink" title="25.8. 跨域是什么, 如何解决跨域?"></a>25.8. 跨域是什么, 如何解决跨域?</h2><p>当 ajax 请求所在域名或接口和请求目标 url 的域名或接口, 有一个不同, 即发生了跨域请求, 浏览器会阻止这次 ajax 请求.</p>
<p>解决跨域请求的方法：</p>
<ol>
<li>如果能让后台改代码, 可以让后台开启跨域支持/ 使用 jsonp 方式处理跨域</li>
<li>如果不能让后台改代码, 则需要在本地使用服务器, 进行代理转发；</li>
</ol>
<h2 id="25-9-express4-中-app-和-router-的区别"><a href="#25-9-express4-中-app-和-router-的区别" class="headerlink" title="25.9. express4 中 app 和 router 的区别"></a>25.9. express4 中 app 和 router 的区别</h2><p>app 可以认为是全局的，方便注入中间件；router 主要针对具体的 routing，除了注入中间件，具体处理 routing 对应的核心业务逻辑；<br>app 级路由不方便模块化封装，而且 app.js 文件没有路由代码，路由代码在 router 文件中，而且 router 方便模块化封装</p>
<h2 id="25-10-Cookies-如何防范-XSS-攻击？"><a href="#25-10-Cookies-如何防范-XSS-攻击？" class="headerlink" title="25.10. Cookies 如何防范 XSS 攻击？"></a>25.10. Cookies 如何防范 XSS 攻击？</h2><p>XSS(Cross-Site Scripting，跨站脚本攻击)是指攻击者在返回的 HTML 中插入 JavaScript 脚本。为了减轻这些攻击，需要在 HTTP 头部配置 set-cookie:</p>
<ul>
<li><p>HttpOnly - 这个属性可以防止 cross-site scripting，因为它会禁止 Javascript 脚本访问 cookie。</p>
</li>
<li><p>secure - 这个属性告诉浏览器仅在请求为 HTTPS 时发送 cookie。</p>
</li>
</ul>
<p>结果应该是这样的: Set-Cookie: sid=; HttpOnly. 使用 Express 的话，cookie-session 默认配置好了。</p>
<h2 id="25-11-Koa-和-Express-的对比"><a href="#25-11-Koa-和-Express-的对比" class="headerlink" title="25.11. Koa 和 Express 的对比"></a>25.11. Koa 和 Express 的对比</h2><ol>
<li>Express 是一个完整的 nodejs 应用框架。Koa 是由 Express 团队开发的，但是它有不同的关注点。Koa 致力于核心中间件功能。nodejs 中间件是访问请求对象（req）和响应对象（res）的例程。 Express 包含一个完整的应用程序框架，具有路由和模板等功能。</li>
<li>Koa 对 Express 进行了扩展，并充分利用了 ES7 新的语法。Koa 的 Context 对象是对 Express 核心请求和应答对象的扩展，另外利用 async/await 来消除回调（callback）陷阱。</li>
<li>Koa 的中间件的设计是洋葱模型。</li>
<li>Koa 不是立即响应，是整个中间件处理完成在最外层进行了响应，而 Express 则是立即响应</li>
</ol>
<h1 id="26-KOA"><a href="#26-KOA" class="headerlink" title="26. KOA"></a>26. KOA</h1><h2 id="26-1-KOA-洋葱模型"><a href="#26-1-KOA-洋葱模型" class="headerlink" title="26.1. KOA 洋葱模型"></a>26.1. KOA 洋葱模型</h2><p>中间件执行就像洋葱一样，最早 use 的中间件，就放在最外层。处理顺序从左到右，左边接收一个 request，右边输出返回 response。<br>一般的中间件都会执行两次，调用 next 之前为第一次，调用 next 时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行 next 函数时，就将依次恢复上游中间件的行为，让上游中间件执行 next 之后的代码。</p>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><br><br><br><br><br></h1></blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jackniu81.github.io/2021/03/02/mobile-ux-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack">
      <meta itemprop="description" content="Full stack engineer, focus on: Angular/React, node.js/.Net">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jack N @ GitHub">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/mobile-ux-performance/" class="post-title-link" itemprop="url">移动端如何做好用户体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-02 13:06:00 / Modified: 17:08:37" itemprop="dateCreated datePublished" datetime="2021-03-02T13:06:00+08:00">2021-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#1-%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">1. 在移动端如何做好用户体验</a></li>
<li><a href="#2-%E6%80%BB%E7%BB%93">2. 总结</a></li>
</ul>
<h1 id="1-在移动端如何做好用户体验"><a href="#1-在移动端如何做好用户体验" class="headerlink" title="1. 在移动端如何做好用户体验"></a>1. 在移动端如何做好用户体验</h1><ul>
<li>清晰的视觉纵线</li>
<li>信息的分组</li>
<li>极致的减法</li>
<li>利用选择代替输入</li>
<li>标签以及文字的排布方式</li>
<li>依靠明文确认密码</li>
<li>合理地利用键盘</li>
</ul>
<h1 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h1><ol>
<li></li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jack</p>
  <div class="site-description" itemprop="description">Full stack engineer, focus on: Angular/React, node.js/.Net</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
