<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <!-- Google Tag Manager -->
  <script>(function (w, d, s, l, i) {
    w[l] = w[l] || []; w[l].push({
      'gtm.start':
        new Date().getTime(), event: 'gtm.js'
    }); var f = d.getElementsByTagName(s)[0],
      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
        'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-TFJ6HHB');</script>
  <!-- End Google Tag Manager -->


  
  <title>Jack N @ GitHub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jack N @ GitHub">
<meta property="og:url" content="jackniu81.github.io/index.html">
<meta property="og:site_name" content="Jack N @ GitHub">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jack N @ GitHub">
  
  <link rel="alternative" href="/atom.xml" title="Jack N @ GitHub" type="application/atom+xml">
  
  
  <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head></html>

<body>

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TFJ6HHB" height="0" width="0"
      style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->


  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jack N @ GitHub</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Full stack engineer, focus on: angular/vue, node.js/java/dotnet, Cordova</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="jackniu81.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CSS-interview-qa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/07/CSS-interview-qa/" class="article-date">
  <time datetime="2021-03-07T05:06:00.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/07/CSS-interview-qa/">CSS面试题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSS实现水平垂直居中"><a href="#CSS实现水平垂直居中" class="headerlink" title="CSS实现水平垂直居中"></a>CSS实现水平垂直居中</h1><ol>
<li>margin: auto;实现绝对定位元素的居中</li>
</ol>
<pre><code class="css"><span class="selector-class">.center-vertical</span>{
    <span class="attribute">width</span>: <span class="number">100px</span>;
    <span class="attribute">height</span>: <span class="number">100px</span>;
    <span class="attribute">background</span>: orange;
    <span class="attribute">position</span>: absolute;
    <span class="attribute">top</span>: <span class="number">0</span>;
    <span class="attribute">left</span>: <span class="number">0</span>;
    <span class="attribute">right</span>: <span class="number">0</span>;
    <span class="attribute">bottom</span>: <span class="number">0</span>;
    <span class="attribute">margin</span>: auto;
}
</code></pre>
<ol start="2">
<li>CSS3.0弹性布局<pre><code class="css"><span class="selector-tag">html</span>,
<span class="selector-tag">body</span> {
  <span class="attribute">width</span>: <span class="number">100%</span>;
  <span class="attribute">height</span>: <span class="number">100%</span>;
}
<span class="selector-tag">body</span> {
  <span class="attribute">display</span>: flex;
  <span class="attribute">align-items</span>: center;
  <span class="attribute">justify-content</span>: center; <span class="comment">/* 定义body的元素水平居中 */</span>
}
<span class="selector-class">.content</span> {
  <span class="attribute">width</span>: <span class="number">300px</span>;
  <span class="attribute">height</span>: <span class="number">300px</span>;
  <span class="attribute">background</span>: orange;
}
</code></pre>
</li>
</ol>
<h1 id="行内元素有哪些？块级元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？"></a>行内元素有哪些？块级元素有哪些？</h1><ol>
<li>行内元素有：<code>a b span img input select strong</code></li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li>
<li>常见的空元素：    <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ol>
<h1 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h1><ol>
<li>新增各种CSS选择器  （: not(.input)：）</li>
<li>圆角            （border-radius:8px）</li>
<li>多列布局      （multi-column layout）</li>
<li>阴影和反射   （Shadow\Reflect）</li>
<li>文字特效      （text-shadow）</li>
<li>文字渲染      （Text-decoration）</li>
<li>线性渐变      （gradient）</li>
<li>旋转            （transform）</li>
<li>缩放,定位,倾斜,动画,多背景</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/03/07/CSS-interview-qa/" data-id="ckmva0jeo000wpk9xdxf23lrw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node-js-interview-qa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/02/node-js-interview-qa/" class="article-date">
  <time datetime="2021-03-02T06:06:00.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/02/node-js-interview-qa/">node.js 面试题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-nodejs-有哪些特点">1. nodejs 有哪些特点？</a></li>
<li><a href="#2-什么是事件循环-event-loop">2. 什么是事件循环 Event Loop</a></li>
<li><a href="#3-在每个-tick-的过程中如何判断是否有事件需要处理呢">3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？</a></li>
<li><a href="#4-什么是回调函数">4. 什么是回调函数？</a></li>
<li><a href="#5-nodejs-计时器-promisethenprocessnexttick-settimeoutsetimmediate-执行顺序">5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序</a></li>
<li><a href="#6-next-tick-和-setimmediate-的区别是什么">6. next tick 和 setImmediate 的区别是什么？</a></li>
<li><a href="#7-nodejs-模块加载机制">7. node.js 模块加载机制</a></li>
<li><a href="#8-什么是-globals">8. 什么是 globals?</a></li>
<li><a href="#9-什么是-eventemitter">9. 什么是 EventEmitter?</a></li>
<li><a href="#10-process-有哪些常用方法">10. process 有哪些常用方法?</a></li>
<li><a href="#11-解释一下什么是-reactor-pattern">11. 解释一下什么是 reactor pattern。</a></li>
<li><a href="#12-什么是错误优先的回调函数">12. 什么是错误优先的回调函数</a></li>
<li><a href="#13-如何避免回调地狱">13. 如何避免回调地狱</a></li>
<li><a href="#14-什么是-promise">14. 什么是 Promise?</a></li>
<li><a href="#15-使用-npm-有哪些好处">15. 使用 NPM 有哪些好处？</a></li>
<li><a href="#16-什么是-stub">16. 什么是 Stub？</a></li>
<li><a href="#17-什么是测试金字塔">17. 什么是测试金字塔？</a></li>
<li><a href="#18-node-模块机制">18. Node 模块机制</a></li>
<li><a href="#19-nodejs-require-的模块加载机制">19. Node.js require 的模块加载机制</a></li>
<li><a href="#20-v8-的垃圾回收机制">20. V8 的垃圾回收机制</a></li>
<li><a href="#21-child-process">21. child-process</a></li>
<li><a href="#22-创建子进程的方法有哪些简单说一下它们的区别">22. 创建子进程的方法有哪些，简单说一下它们的区别</a></li>
<li><a href="#23-怎样充分利用多个-cpu">23. 怎样充分利用多个 CPU?</a></li>
<li><a href="#24-有哪些方法可以让-node-程序遇到错误后自动重启">24. 有哪些方法可以让 node 程序遇到错误后自动重启?</a></li>
<li><a href="#25-关于-express-框架">25. 关于 Express 框架</a><ul>
<li><a href="#251-express-生成器的作用是什么">25.1. express 生成器的作用是什么?</a></li>
<li><a href="#252-express-优点是什么">25.2. express 优点是什么?</a></li>
<li><a href="#253-什么是中间件">25.3. 什么是中间件</a></li>
<li><a href="#254-express-缺点是什么">25.4. express 缺点是什么?</a></li>
<li><a href="#255-ejs-作用是什么">25.5. ejs 作用是什么?</a></li>
<li><a href="#256-什么是后端渲染项目">25.6. 什么是后端渲染项目?</a></li>
<li><a href="#257-session-和-cookie-的作用和区别">25.7. session 和 cookie 的作用和区别?</a></li>
<li><a href="#258-跨域是什么-如何解决跨域">25.8. 跨域是什么, 如何解决跨域?</a></li>
<li><a href="#259-express4-中-app-和-router-的区别">25.9. express4 中 app 和 router 的区别</a></li>
<li><a href="#2510-cookies-如何防范-xss-攻击">25.10. Cookies 如何防范 XSS 攻击？</a></li>
<li><a href="#2511-koa-和-express-的对比">25.11. Koa 和 Express 的对比</a></li>
</ul>
</li>
<li><a href="#26-koa">26. KOA</a><ul>
<li><a href="#261-koa-洋葱模型">26.1. KOA 洋葱模型</a></li>
</ul>
</li>
</ul>
<h1 id="1-nodejs-有哪些特点？"><a href="#1-nodejs-有哪些特点？" class="headerlink" title="1. nodejs 有哪些特点？"></a>1. nodejs 有哪些特点？</h1><p>是单线程的，但是有很高的可扩展性，使用 JavaScript 作为主流编程语言。使用的是<code>非阻塞IO,异步处理机制和事件驱动</code>。处理高效。</p>
<p>擅长 IO 密集型业务业务处理，不擅长 CPU 密集型业务；</p>
<h1 id="2-什么是事件循环-Event-Loop"><a href="#2-什么是事件循环-Event-Loop" class="headerlink" title="2. 什么是事件循环 Event Loop"></a>2. 什么是事件循环 Event Loop</h1><p>在进程启动动时，Node 会创建一个类似于 while(true)的循环，每执行一次循环的过程我们称之为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有，就取出时间相关的回调函数。如果存在相关联的回调函数，就执行它们。然后进入下一个循环；如果不再有事件待处理，就退出进程。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │       <span class="built_in"> check </span>         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<ol>
<li>timers: 这个阶段执行 setTimeout()和 setInterval()设定的回调。</li>
<li>I/O callbacks: 执行几乎所有的回调，除了 close 回调，timer 的回调，和 setImmediate()的回调。</li>
<li>idle, prepare: 仅内部使用。</li>
<li>poll: 获取新的 I/O 事件；node 会在适当条件下阻塞在这里。</li>
<li>check: 执行 setImmediate()设定的回调。</li>
<li>close callbacks: 执行比如 socket.on(‘close’, …)的回调。</li>
</ol>
<p>简单理解 Event Loop 如下：</p>
<ol>
<li>所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack)</li>
<li>在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务</li>
<li>一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p>在底层， Node 是通过 libuv 来实现多线程的。<code>Libuv</code>库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环， 以异步的方式将任务的执行结果返回给 V8 引擎。可</p>
<h1 id="3-在每个-tick-的过程中，如何判断是否有事件需要处理呢？"><a href="#3-在每个-tick-的过程中，如何判断是否有事件需要处理呢？" class="headerlink" title="3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？"></a>3. 在每个 tick 的过程中，如何判断是否有事件需要处理呢？</h1><ol>
<li>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</li>
<li>在 Node 中，事件主要来源于网络请求、文件的 I/O 等，这些事件对应的观察者有文件 I/O 观察者，网络 I/O 的观察者。</li>
<li>事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</li>
</ol>
<h1 id="4-什么是回调函数？"><a href="#4-什么是回调函数？" class="headerlink" title="4. 什么是回调函数？"></a>4. 什么是回调函数？</h1><p>回调函数是指用一个函数作为参数传入另一个函数，这个函数会被在某个时机调用。</p>
<h1 id="5-node-js-计时器-promise-then-process-nextTick-setTimeout，setImmediate-执行顺序"><a href="#5-node-js-计时器-promise-then-process-nextTick-setTimeout，setImmediate-执行顺序" class="headerlink" title="5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序"></a>5. node.js 计时器 promise.then,process.nextTick, setTimeout，setImmediate 执行顺序</h1><p>首先了解 2 个概念</p>
<ul>
<li>macro-task（宏任务）: script ，setTimeout, setInterval, setImmediate, I/O, UI rendering.Event Loop 在每个阶段执行的任务；</li>
<li>micro-task （微任务）: process.nextTick, Promise，Object. fvEvent Loop 在每个阶段之间执行的任务 observe，MutationObserver</li>
</ul>
<p>对于 node.js, micro-task 的任务优先级高于 macro-task 的任务优先级,所以微任务普遍优先于宏任务的执行。</p>
<p>另一种优先级顺序，是“观察者优先级”， 在每次轮训检查中，各观察者的优先级分别是：<code>idle观察者 &gt; I/O观察者 &gt; check观察者。</code></p>
<ul>
<li>idle 观察者：process.nextTick</li>
<li>I/O 观察者：一般性的 I/O 回调，如网络，文件，数据库 I/O 等</li>
<li>check 观察者：setTimeout &gt; setImmediate (setTimeout(()=&gt;{},0)优先于 setImmediate 执行）；</li>
<li><strong>总结</strong></li>
</ul>
<ol>
<li>同步代码执行顺序优先级高于异步代码执行顺序优先级；</li>
<li>new Promise(fn)中的 fn 是同步执行；</li>
<li>process.nextTick()&gt;Promise.then()&gt;setTimeout&gt;setImmediate。</li>
</ol>
<h1 id="6-next-tick-和-setImmediate-的区别是什么？"><a href="#6-next-tick-和-setImmediate-的区别是什么？" class="headerlink" title="6. next tick 和 setImmediate 的区别是什么？"></a>6. next tick 和 setImmediate 的区别是什么？</h1><ul>
<li><p>NextTick 会等待当前的 event 执行完成或者下一轮儿事件循环到达再执行。</p>
</li>
<li><p>SetImmediate, 会在下一轮的事件循环中，执行回调并且返回当前的循环来做读写操作.</p>
</li>
</ul>
<h1 id="7-node-js-模块加载机制"><a href="#7-node-js-模块加载机制" class="headerlink" title="7. node.js 模块加载机制"></a>7. node.js 模块加载机制</h1><p>Nodejs 遵循 commonjs 规范的模块加载机制，使用 require 加载文件，使用 exports 或 module.exports 导出文件</p>
<h1 id="8-什么是-globals"><a href="#8-什么是-globals" class="headerlink" title="8. 什么是 globals?"></a>8. 什么是 globals?</h1><p>有三个 global 的关键字。</p>
<ol>
<li>Global 代表的是最上层的命名空间,用来管理所有其他的全局对象。</li>
<li>Process 是一个全局对象，可以把异步函数转化成异步回调, 它可以在任何地方被访问，它主要是用来返回系统的应用信息和环境信息.</li>
<li>Buffer, 是用来处理二进制数据的类.</li>
</ol>
<h1 id="9-什么是-EventEmitter"><a href="#9-什么是-EventEmitter" class="headerlink" title="9. 什么是 EventEmitter?"></a>9. 什么是 EventEmitter?</h1><p>EventEmitter 是 node 中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题.</p>
<p>主要用于： 1) 模块间传递消息 2) 回调函数内外传递消息 3) 处理流数据，因为流是在 EventEmitter 基础上实现的. 4) 观察者模式发射触发机制相关应用</p>
<h1 id="10-process-有哪些常用方法"><a href="#10-process-有哪些常用方法" class="headerlink" title="10. process 有哪些常用方法?"></a>10. process 有哪些常用方法?</h1><p>process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>
<h1 id="11-解释一下什么是-reactor-pattern。"><a href="#11-解释一下什么是-reactor-pattern。" class="headerlink" title="11. 解释一下什么是 reactor pattern。"></a>11. 解释一下什么是 reactor pattern。</h1><p>reactor 设计模式是 event-driven architecture 的一种实现方式，处理多个客户端并发的向服务端请求服务的场景。每种服务在服务端可能由多个方法组成。reactor 会解耦并发请求的服务并分发给对应的事件处理器来处理。</p>
<p>Reactor pattern 主要是非阻滞的 i/o 操作。提供一个回调函数来关联 io 操作。io 请求完成以后会不会提交给 demultiplexer, 这是一个通知接口用来处理并发性的非阻滞的 io 操作，这个功能是通过查询一个 event loop 来实现的.</p>
<h1 id="12-什么是错误优先的回调函数"><a href="#12-什么是错误优先的回调函数" class="headerlink" title="12. 什么是错误优先的回调函数"></a>12. 什么是错误优先的回调函数</h1><p>node.js 广泛使用异步编程，而异步中的异常很难在主程序中捕获。为此，我们将异步中的异常、错误，通过回调函数传递给主程序。</p>
<p>错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。</p>
<h1 id="13-如何避免回调地狱"><a href="#13-如何避免回调地狱" class="headerlink" title="13. 如何避免回调地狱"></a>13. 如何避免回调地狱</h1><ol>
<li>模块化：将回调函数分割为独立的函数</li>
<li>使用 Promise/ansyc (ES6)</li>
<li>使用 yield 来计算生成器或 Promise</li>
</ol>
<h1 id="14-什么是-Promise"><a href="#14-什么是-Promise" class="headerlink" title="14. 什么是 Promise?"></a>14. 什么是 Promise?</h1><p>Promise 可以帮助我们更好地处理异步操作。采用类似同步结构的代码，实现异步处理，同时避免回调地狱。</p>
<h1 id="15-使用-NPM-有哪些好处？"><a href="#15-使用-NPM-有哪些好处？" class="headerlink" title="15. 使用 NPM 有哪些好处？"></a>15. 使用 NPM 有哪些好处？</h1><p>通过 NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于 Node 应用开发而言，你可以通过 package.json 文件来管理项目信息，配置脚本， 以及指明项目依赖的具体版本。</p>
<h1 id="16-什么是-Stub？"><a href="#16-什么是-Stub？" class="headerlink" title="16. 什么是 Stub？"></a>16. 什么是 Stub？</h1><p>Stub 是用于模拟一个组件或模块的函数或程序，在测试用例中很常用。简单的说，你可以用 Stub 去模拟一个方法，从而避免调用真实的方法， 使用 Stub 你还可以返回虚构的结果。你可以配合断言使用 Stub。</p>
<h1 id="17-什么是测试金字塔？"><a href="#17-什么是测试金字塔？" class="headerlink" title="17. 什么是测试金字塔？"></a>17. 什么是测试金字塔？</h1><p>测试金字塔指的是： 测试用例从下到上，包括单元测试、集成测试、端到端测试；当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。</p>
<h1 id="18-Node-模块机制"><a href="#18-Node-模块机制" class="headerlink" title="18. Node 模块机制"></a>18. Node 模块机制</h1><p>Node 中，每个文件模块都是一个对象，所有的模块都是 Module 的实例。</p>
<h1 id="19-Node-js-require-的模块加载机制"><a href="#19-Node-js-require-的模块加载机制" class="headerlink" title="19. Node.js require 的模块加载机制"></a>19. Node.js require 的模块加载机制</h1><p>1、先计算模块路径<br>2、如果模块在缓存里面，取出缓存；如果不存在生成模块实例，存入缓存<br>3、加载模块<br>4、输出模块的 exports 属性</p>
<h1 id="20-V8-的垃圾回收机制"><a href="#20-V8-的垃圾回收机制" class="headerlink" title="20. V8 的垃圾回收机制"></a>20. V8 的垃圾回收机制</h1><p>在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。<br><strong>新生代</strong>中的对象主要通过 Scavenge 算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一份为二，分为 2 个 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。</p>
<ol>
<li>当开始垃圾回收的时候，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间发生角色对换。</li>
<li>应为新生代中对象的生命周期比较短，就比较适合这个算法。</li>
<li>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。<br><strong>老生代</strong>主要采取的是标记清除的垃圾回收算法。与 Scavenge 复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。</li>
</ol>
<p><strong>标记清楚算法的问题</strong>：<br>主要问题是每一次进行标记清除回收后，内存空间会出现不连续的状态</p>
<ol>
<li>这种内存碎片会对后续内存分配造成问题，很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</li>
<li>为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</li>
</ol>
<h1 id="21-child-process"><a href="#21-child-process" class="headerlink" title="21. child-process"></a>21. child-process</h1><p>node 是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统 shell 命令交互，调用可执行文件，创建子进程进行阻塞式访问或高 CPU 计算等，child-process 就是为满足这些需求而生的．child-process 顾名思义，就是把 node 阻塞的工作交给子进程去做．</p>
<h1 id="22-创建子进程的方法有哪些，简单说一下它们的区别"><a href="#22-创建子进程的方法有哪些，简单说一下它们的区别" class="headerlink" title="22. 创建子进程的方法有哪些，简单说一下它们的区别"></a>22. 创建子进程的方法有哪些，简单说一下它们的区别</h1><p>创建子进程的方法大致有：</p>
<ol>
<li>spawn()： 启动一个子进程来执行命令</li>
<li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li>
<li>execFlie(): 启动一个子进程来执行可执行文件</li>
<li>fork(): 与 spawn()类似，不同电在于它创建 Node 子进程需要执行 js 文件</li>
<li>spawn()与 exec()、execFile()不同的是，后两者创建时可以指定 timeout 属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死</li>
<li>exec()与 execFile()不同的是，exec()适合执行已有命令，execFile()适合执行文件。</li>
</ol>
<p>（exec 可以用操作系统原生的方式执行各种命令，如管道 cat ab.txt | grep hello; execFile 是执行一个文件; spawn 是流式和操作系统进行交互; fork 是两个 node 程序(javascript)之间时行交互.）</p>
<h1 id="23-怎样充分利用多个-CPU"><a href="#23-怎样充分利用多个-CPU" class="headerlink" title="23. 怎样充分利用多个 CPU?"></a>23. 怎样充分利用多个 CPU?</h1><p>一个 CPU 运行一个 node 实例。 （Child_Process)</p>
<h1 id="24-有哪些方法可以让-node-程序遇到错误后自动重启"><a href="#24-有哪些方法可以让-node-程序遇到错误后自动重启" class="headerlink" title="24. 有哪些方法可以让 node 程序遇到错误后自动重启?"></a>24. 有哪些方法可以让 node 程序遇到错误后自动重启?</h1><p>Linxu: 1) runit 2) forever 3) nohup npm start &amp;<br>Winwow: Windows service(auto restart)</p>
<h1 id="25-关于-Express-框架"><a href="#25-关于-Express-框架" class="headerlink" title="25. 关于 Express 框架"></a>25. 关于 Express 框架</h1><h2 id="25-1-express-生成器的作用是什么"><a href="#25-1-express-生成器的作用是什么" class="headerlink" title="25.1. express 生成器的作用是什么?"></a>25.1. express 生成器的作用是什么?</h2><p>通过应用生成器工具 express-generator 可以快速创建一个应用的框架, 包含一整套配置好的服务器配置, 文件和文件夹等, 包括静态资源的暴露等, 包括路由的配置, 和模板引擎配置, 以及 404 的处理，异常处理等；</p>
<h2 id="25-2-express-优点是什么"><a href="#25-2-express-优点是什么" class="headerlink" title="25.2. express 优点是什么?"></a>25.2. express 优点是什么?</h2><p>Express 的优点是线性逻辑：路由和中间件完美融合，通过中间件形式把业务逻辑细分，简化，一个请求进来经过一系列中间件处理后再响应给用户，再复杂的业务也是线性了，清晰明了。</p>
<h2 id="25-3-什么是中间件"><a href="#25-3-什么是中间件" class="headerlink" title="25.3. 什么是中间件"></a>25.3. 什么是中间件</h2><ul>
<li>中间件是可以访问请求对象，响应对象以及 next 应用程序请求-响应周期中的函数，使用 app.use()来使用/定义中间件；</li>
<li>Express 是一个自身功能极简，完全是路由和中间件构成一个 web 开发框架；</li>
<li>从本质上来说，一个 Express 应用就是在调用各种中间件。封装了一些或许复杂但肯定是通用的功能, 非内置的中间件需要通过安装后，require 到文件就可以运行。</li>
</ul>
<h2 id="25-4-express-缺点是什么"><a href="#25-4-express-缺点是什么" class="headerlink" title="25.4. express 缺点是什么?"></a>25.4. express 缺点是什么?</h2><p>Express 是基于 callback 来组合业务逻辑。Callback 有两大硬伤，一是<code>不可组合</code>，二是<code>异常不可捕获</code>。</p>
<h2 id="25-5-ejs-作用是什么"><a href="#25-5-ejs-作用是什么" class="headerlink" title="25.5. ejs 作用是什么?"></a>25.5. ejs 作用是什么?</h2><p>EJS 是一个 Javascript 模板库, 用来从 JSON 数据中生成 HTML 文件。其他模板库（模板引擎如 jade/pug);</p>
<h2 id="25-6-什么是后端渲染项目"><a href="#25-6-什么是后端渲染项目" class="headerlink" title="25.6. 什么是后端渲染项目?"></a>25.6. 什么是后端渲染项目?</h2><p>浏览器请求静态网页资源, 服务器端会在后端把数据渲染到 HTML 页面上, 再把 html 文件内的字符串一起返回给浏览器进行展示的一种手段, Nodejs 中体现为 ejs 和 pug 模板引擎；</p>
<h2 id="25-7-session-和-cookie-的作用和区别"><a href="#25-7-session-和-cookie-的作用和区别" class="headerlink" title="25.7. session 和 cookie 的作用和区别?"></a>25.7. session 和 cookie 的作用和区别?</h2><p>session 是区别于数据库存在的一种服务器临时存储技术, 它主要存储一些无需持久化的数据, 比如临时的登录状态信息等</p>
<p>cookie 是存在于浏览器上的一种浏览器本地存储的方式, 同域名下的 cookie 不同标签页可以共享, 默认过期时间是浏览器关闭时, 而且在进行 http 请求时, 会自动带上浏览器全部的 cookie 发给后台, 后台也可以获取 cookie, 设置可以在响应时, 想浏览器中设置 cookie。</p>
<h2 id="25-8-跨域是什么-如何解决跨域"><a href="#25-8-跨域是什么-如何解决跨域" class="headerlink" title="25.8. 跨域是什么, 如何解决跨域?"></a>25.8. 跨域是什么, 如何解决跨域?</h2><p>当 ajax 请求所在域名或接口和请求目标 url 的域名或接口, 有一个不同, 即发生了跨域请求, 浏览器会阻止这次 ajax 请求.</p>
<p>解决跨域请求的方法：</p>
<ol>
<li>如果能让后台改代码, 可以让后台开启跨域支持/ 使用 jsonp 方式处理跨域</li>
<li>如果不能让后台改代码, 则需要在本地使用服务器, 进行代理转发；</li>
</ol>
<h2 id="25-9-express4-中-app-和-router-的区别"><a href="#25-9-express4-中-app-和-router-的区别" class="headerlink" title="25.9. express4 中 app 和 router 的区别"></a>25.9. express4 中 app 和 router 的区别</h2><p>app 可以认为是全局的，方便注入中间件；router 主要针对具体的 routing，除了注入中间件，具体处理 routing 对应的核心业务逻辑；<br>app 级路由不方便模块化封装，而且 app.js 文件没有路由代码，路由代码在 router 文件中，而且 router 方便模块化封装</p>
<h2 id="25-10-Cookies-如何防范-XSS-攻击？"><a href="#25-10-Cookies-如何防范-XSS-攻击？" class="headerlink" title="25.10. Cookies 如何防范 XSS 攻击？"></a>25.10. Cookies 如何防范 XSS 攻击？</h2><p>XSS(Cross-Site Scripting，跨站脚本攻击)是指攻击者在返回的 HTML 中插入 JavaScript 脚本。为了减轻这些攻击，需要在 HTTP 头部配置 set-cookie:</p>
<ul>
<li><p>HttpOnly - 这个属性可以防止 cross-site scripting，因为它会禁止 Javascript 脚本访问 cookie。</p>
</li>
<li><p>secure - 这个属性告诉浏览器仅在请求为 HTTPS 时发送 cookie。</p>
</li>
</ul>
<p>结果应该是这样的: Set-Cookie: sid=; HttpOnly. 使用 Express 的话，cookie-session 默认配置好了。</p>
<h2 id="25-11-Koa-和-Express-的对比"><a href="#25-11-Koa-和-Express-的对比" class="headerlink" title="25.11. Koa 和 Express 的对比"></a>25.11. Koa 和 Express 的对比</h2><ol>
<li>Express 是一个完整的 nodejs 应用框架。Koa 是由 Express 团队开发的，但是它有不同的关注点。Koa 致力于核心中间件功能。nodejs 中间件是访问请求对象（req）和响应对象（res）的例程。 Express 包含一个完整的应用程序框架，具有路由和模板等功能。</li>
<li>Koa 对 Express 进行了扩展，并充分利用了 ES7 新的语法。Koa 的 Context 对象是对 Express 核心请求和应答对象的扩展，另外利用 async/await 来消除回调（callback）陷阱。</li>
<li>Koa 的中间件的设计是洋葱模型。</li>
<li>Koa 不是立即响应，是整个中间件处理完成在最外层进行了响应，而 Express 则是立即响应</li>
</ol>
<h1 id="26-KOA"><a href="#26-KOA" class="headerlink" title="26. KOA"></a>26. KOA</h1><h2 id="26-1-KOA-洋葱模型"><a href="#26-1-KOA-洋葱模型" class="headerlink" title="26.1. KOA 洋葱模型"></a>26.1. KOA 洋葱模型</h2><p>中间件执行就像洋葱一样，最早 use 的中间件，就放在最外层。处理顺序从左到右，左边接收一个 request，右边输出返回 response。<br>一般的中间件都会执行两次，调用 next 之前为第一次，调用 next 时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行 next 函数时，就将依次恢复上游中间件的行为，让上游中间件执行 next 之后的代码。</p>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
<h1 id><a href="#" class="headerlink" title></a><br><br><br><br><br></h1></blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/03/02/node-js-interview-qa/" data-id="ckmva0jfr001ipk9xm7gbycpl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js-面试题/">node.js - 面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mobile-ux-performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/02/mobile-ux-performance/" class="article-date">
  <time datetime="2021-03-02T05:06:00.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/02/mobile-ux-performance/">移动端如何做好用户体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-在移动端如何做好用户体验">1. 在移动端如何做好用户体验</a></li>
<li><a href="#2-总结">2. 总结</a></li>
</ul>
<h1 id="1-在移动端如何做好用户体验"><a href="#1-在移动端如何做好用户体验" class="headerlink" title="1. 在移动端如何做好用户体验"></a>1. 在移动端如何做好用户体验</h1><ul>
<li>清晰的视觉纵线</li>
<li>信息的分组</li>
<li>极致的减法</li>
<li>利用选择代替输入</li>
<li>标签以及文字的排布方式</li>
<li>依靠明文确认密码</li>
<li>合理地利用键盘</li>
</ul>
<h1 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h1><ol>
<li><p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/03/02/mobile-ux-performance/" data-id="ckmva0jfq001gpk9x1x259rrz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobile/">mobile</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Angular-keyword" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/09/Angular-keyword/" class="article-date">
  <time datetime="2021-02-09T05:06:00.000Z" itemprop="datePublished">2021-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/09/Angular-keyword/">Angular 词汇表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-概要">1. 概要</a></li>
<li><a href="#1-概要-1">1. 概要</a></li>
</ul>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>大多数 Angular 短语都是日常用语或计算机术语，但是在 Angular 体系中，它们有特别的含义。</p>
<h1 id="1-概要-1"><a href="#1-概要-1" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>预编译 (ahead-of-time, AOT)<br>即时编译 (just-in-time, JIT)<br>Angular元素（element， Angular Element）<br>注解（Annotation）: 注解也叫装饰器；<br>装饰器（decorator | decoration）: 注解也叫装饰器；<br>应用外壳（app-shell）<br>架构（Architect）<br>指令 directives<br>属性型指令（attribute directives）<br>绑定 (binding)<br>启动/引导 (bootstrap)<br>构建器（Builder）<br>大小写类型（case types）<br>小驼峰形式（camelCase）：小驼峰（也叫标准驼峰）形式的第一个字母要使用小写形式。<br>大驼峰形式（UpperCamelCase）或叫帕斯卡形式（PascalCase）<br>中线形式（dash-case）或叫烤串形式（kebab-case）<br>下划线形式（underscore_case）或叫蛇形形式（snake_case）<br>大写下划线形式（UPPER_UNDERSCORE_CASE）或叫大写蛇形形式（UPPER_SNAKE_CASE）<br>变更检测（change detection）<br>类装饰器（class decorator）<br>类字段装饰器（class field decorator）<br>集合（collection）<br>命令行工具,命令行客户端（CLI， Angular CLI）<br>组件 (component)<br>配置（configuration）<br>内容投影 （content projection）<br>自定义元素（Custom element）:也叫 Web Component<br>数据绑定 (data binding)<br>可声明对象（declarable）<br>装饰器（decorator | decoration）<br>依赖注入（dependency injection）<br>DI 令牌（Token）<br>差异化加载 (differential loading)<br>指令 (directive)<br>领域特定语言（domain-specific language, DSL)<br>动态组件加载（dynamic component loading）<br>急性加载（Eager Loading）<br>惰性加载（Lazy loading）<br>元素（Element, Angular Element）<br>入口点（Entry Point）<br>表单控件（form control）<br>表单模型（form model）<br>表单验证（form validation）<br>不可变性（immutability）<br>可注入对象（injectable）<br>注入器 (injector)<br>输入属性 (input)<br>输出属性 (output)<br>插值 (interpolation)<br>常春藤引擎（Ivy）<br>惰性加载（Lazy loading）<br>库（Library）<br>生命周期钩子（Lifecycle hook）<br>模块 (module)<br>ngcc (Angular 兼容性编译器)<br>npm 包 (npm package)<br>ngc (ngc 是一个 TypeScript 到 JavaScript 的转译器)<br>可观察对象（Observable）<br>观察者（Observer）<br>管道（pipe）<br>平台（platform）<br>腻子脚本（polyfill）<br>项目（project）<br>提供者 (provider)<br>响应式表单 (reactive forms)<br>解析器（resolver）<br>路由守卫 (route guard)<br>路由器 (router)<br>路由出口（router outlet）<br>路由组件 (routing component)<br>规则（rule）<br>原理图（schematic）<br>Schematics CLI (Schematics 自带了一个命令行工具)<br>范围化包 (scoped package)<br>服务端渲染 (server-side rendering)<br>服务 (service)<br>结构型指令（Structural directives）<br>订阅者（Subscriber）<br>目标 (target)<br>模板 (template)<br>模板驱动表单（template-driven forms）<br>模板表达式（template expression）<br>模板引用变量 (template reference variable)<br>令牌（Token）<br>转译（transpile)<br>目录树（tree）<br>TypeScript 配置文件<br>单向数据流 (unidirectional data flow)<br>视图 (view)<br>视图引擎（View Engine）<br>视图树（View hierarchy）<br>Web 组件 (web component)<br>工作空间（Workspace）<br>工作空间配置（Workspace configuration）<br>区域 (zone)</p>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/02/09/Angular-keyword/" data-id="ckmva0jek000rpk9xmhywwm10" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js-speical" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/07/js-speical/" class="article-date">
  <time datetime="2021-02-07T05:06:00.000Z" itemprop="datePublished">2021-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/07/js-speical/">javascript中常见的非人类（java/c#)知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/javascript.jpg" alt></p>
<ul>
<li><a href="#1-概要">1. 概要</a></li>
<li><a href="#2-this">2. this</a></li>
<li><a href="#3-原型链-prototype">3. 原型链, prototype</a></li>
<li><a href="#4-new操作符都做了什么">4. new操作符都做了什么</a></li>
<li><a href="#5--vs-">5. === VS ==</a></li>
<li><a href="#6-闭包">6. 闭包</a></li>
<li><a href="#7-总结">7. 总结</a></li>
</ul>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>众所周期，javascript是一个很老的语言，起起伏伏，逐渐成为流行语言（主流语言），说白了，也是因为早期各个浏览器（ie/firefox/sarfari/chrome)互不妥协，谁也说服不了对方接收自己的标准，不过却都同时支持javascript。对于广大程序员来说，随着web流行度越来越高，那么为了同时支持大多数浏览器，那么使用标准的javascript成为趋势。而第三方（coffeescript, typescript, dart等)也都是选择将代码编译为JavaScript，然后在浏览器端执行。</p>
<p>作为从C#、java等语言转到javascript的同学来说，会发现不少C#、java的“我觉得应该是这样”的东西，JavaScript中却是不一样的。下面总结一下</p>
<h1 id="2-this"><a href="#2-this" class="headerlink" title="2. this"></a>2. this</h1><p>对C#、Java等语言，this就是当前对象，但是javascript不是，简单来说：</p>
<ul>
<li>全局this 是window;</li>
<li>函数this 是调用者;</li>
<li>构造函数的this 是new 之后的新对象,</li>
<li>call 和 apply bind的this第一个参数</li>
</ul>
<h1 id="3-原型链-prototype"><a href="#3-原型链-prototype" class="headerlink" title="3. 原型链, prototype"></a>3. 原型链, prototype</h1><ul>
<li>函数对象都包含prototype属性（函数的原型对象），其作用就是让该函数所实例化的对象们都可以找到公用的属性和方法；</li>
<li>constructor属性的含义就是指向该对象的构造函数</li>
<li>①<strong>proto</strong>和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和constructor属性。</li>
<li>JavaScript 的每个对象都继承另一个父级对象，父级对象称为原型 (prototype) 对象。</li>
<li>每一个实例对象都有一个私有属性<strong>proto</strong>指向其构造函数的原型对象prototype；该原型对象也会作为实例对象有一个私有属性<strong>proto</strong>，层层向上直到一个对象的原型对象值为null。</li>
<li>当访问一个对象的属性或方法时，js引擎会先查找该对象本身是否包含，如果没有，会去该对象的<strong>proto</strong>属性所指向的原型对象上找，如果没有，会继续向上一层找，直到某个对象的<strong>proto</strong>值为null,这就是原型链。</li>
<li>每个构造函数都有一个prototype属性，指向另外一个对象，说明整个对象所有的属性和方法都会被构造函数所拥有。</li>
</ul>
<h1 id="4-new操作符都做了什么"><a href="#4-new操作符都做了什么" class="headerlink" title="4. new操作符都做了什么"></a>4. new操作符都做了什么</h1><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p>
<p>new Object()举例:</p>
<ol>
<li>创建一个新对象</li>
<li>把新对象的原型指向构造函数的prototype</li>
<li>把构造函数里的this指向新对象</li>
<li>返回这个新对象</li>
</ol>
<h1 id="5-VS"><a href="#5-VS" class="headerlink" title="5. === VS =="></a>5. === VS ==</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">'100'</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">''</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>很有意思吧， 看看这两个，是等效的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj == <span class="literal">null</span></span><br><span class="line">obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<h1 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6. 闭包"></a>6. 闭包</h1><p>在JavaScript中的一大特点就是闭包，很多高级应用(早期的jquery，现在的angular、vue)都要依靠闭包来实现。由于闭包会使得函数中的变量都被保存在内存中，会消耗很大的内存，导致页面的性能问题，甚至导致内存泄漏。建议不要或者少用闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> a = <span class="string">"some value"</span>;</span><br><span class="line"> <span class="keyword">var</span> innerMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( a + <span class="string">"!"</span>) ;&#125;</span><br><span class="line"> innerMethod(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><ol>
<li>Javascipt 中有些内容和其他编程语言不一致，需要牢记</li>
<li>JavaScript中拿不准的东西，可以简单测试一下，免得代码写好后出错。</li>
<li>简单测试，可以打开浏览器，直接F12（进入Dev Tools），再选择Console(控制台)， 直接输入要测试的内容，查看返回结果</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/02/07/js-speical/" data-id="ckmva0jfo001dpk9xhq8k2fhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Angular-Starter-15-folder-structure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/29/Angular-Starter-15-folder-structure/" class="article-date">
  <time datetime="2021-01-29T05:06:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/29/Angular-Starter-15-folder-structure/">Angular入门到精通系列教程（15）- 目录结构（工程结构）推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-概要">1. 概要</a></li>
<li><a href="#2-目录结构工程结构推荐">2. 目录结构（工程结构）推荐</a><ul>
<li><a href="#21-总的原则">2.1. 总的原则</a></li>
<li><a href="#22-实例">2.2. 实例</a></li>
<li><a href="#23-共享模块-sharedmodule">2.3. 共享模块-SharedModule</a></li>
</ul>
</li>
<li><a href="#3-高级应用---angular库工作空间workspace-">3. 高级应用 - angular库、工作空间（workspace ）</a><ul>
<li><a href="#31-目录结构示意">3.1. 目录结构示意</a></li>
</ul>
</li>
<li><a href="#4-总结">4. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular CLI: 11.0.6</li>
<li>Angular: 11.0.7</li>
<li>Node: 12.18.3 </li>
<li>npm : 6.14.6</li>
<li>IDE: Visual Studio Code</li>
</ul>
</blockquote>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>实际的Angular项目，肯定不是一个简单的Hello World程序，会包含很多的功能，很多的文件。那么如何更好的组织这些文件呢？官方给了一个原则，可以供参考：<br><a href="https://angular.io/guide/styleguide#application-structure-and-ngmodules。" target="_blank" rel="noopener">https://angular.io/guide/styleguide#application-structure-and-ngmodules。</a><br>下面，我们来通过一个例子具体解释一下。</p>
<h1 id="2-目录结构（工程结构）推荐"><a href="#2-目录结构（工程结构）推荐" class="headerlink" title="2. 目录结构（工程结构）推荐"></a>2. 目录结构（工程结构）推荐</h1><h2 id="2-1-总的原则"><a href="#2-1-总的原则" class="headerlink" title="2.1. 总的原则"></a>2.1. 总的原则</h2><ol>
<li>基于Angular CLI创建模块（module），组件（component）等等的内容；</li>
<li>源代码都放到<code>src</code> 文件夹下；</li>
<li>应用的根目录创建一个 NgModule, 并命名为app.module.ts（例如 /src/app，这个Angular CLI 会自动帮我们做)</li>
<li>组件具有多个伴生文件 (.ts、.html、.css 和 .spec)，建议为它创建一个文件夹;(Angular CLI 会自动帮我们做)</li>
<li>为每一组功能（特性区）创建一个模块（<code>NgModule</code>）；（这个也方便我们应用惰性加载/延迟加载，预加载）</li>
<li>在 src/app/shared 目录中创建名叫 SharedModule 的共享模块，方便其他功能调用； </li>
</ol>
<h2 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2. 实例"></a>2.2. 实例</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">src/ 目录下：</span><br><span class="line">+---app</span><br><span class="line">|   |   app-routing.module.ts</span><br><span class="line">|   |   app.component.css</span><br><span class="line">|   |   app.component.html</span><br><span class="line">|   |   app.component.spec.ts</span><br><span class="line">|   |   app.component.ts</span><br><span class="line">|   |   app.module.ts</span><br><span class="line">|   |   </span><br><span class="line">|   +---feature1</span><br><span class="line">|   |   |   ......</span><br><span class="line">|   |           </span><br><span class="line">|   +---feature1</span><br><span class="line">|   |   |   ......</span><br><span class="line">|   |           </span><br><span class="line">|   +---core</span><br><span class="line">|   |   |   core.module.ts</span><br><span class="line">|   |   |   ....</span><br><span class="line">|   |           </span><br><span class="line">|   \---shared</span><br><span class="line">|       |   shared.module.ts</span><br><span class="line">|       |   </span><br><span class="line">|       +---components</span><br><span class="line">|       +---pipes</span><br><span class="line">|       +---services</span><br><span class="line">|               </span><br><span class="line">+---assets</span><br><span class="line">|       .gitkeep</span><br><span class="line">|       </span><br><span class="line">\---environments</span><br><span class="line">        environment.prod.ts</span><br><span class="line">        environment.ts</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ol>
<li>根目录下的<code>NgModule</code> 默认是 <code>app.module.ts</code>, 不要改名，方便阅读</li>
<li>app 下，每个目录，同时也都是一个模块-<code>NgModule</code></li>
<li>一个项目，一般包含多个功能（feature）模块</li>
<li>推荐使用共享模块-SharedModule，将通用的、功能的功能（service/component/pipe等）放到改模块中。 （下文详细介绍）</li>
<li>推荐使用核心模块-CoreModule，可以将项目的一些全局的设置、UI等放到该模块。如header、footer组件，安全组件（服务），上下文存储服务等。</li>
</ol>
<h2 id="2-3-共享模块-SharedModule"><a href="#2-3-共享模块-SharedModule" class="headerlink" title="2.3. 共享模块-SharedModule"></a>2.3. 共享模块-SharedModule</h2><p>上文提到，推荐使用共享模块-SharedModule，将通用的、功能的功能（service/component/pipe等）放到改模块中。具体存放内容包括：</p>
<ol>
<li>共享模块中声明那些可能被特性模块引用的可复用组件(Component)、指令(Directive)和管道(Pipe)。</li>
<li>如果放置服务（Service），由于服务的单例特性，共享模块中只建议放置无状态的服务（Service），对于有状态、或者和业务紧密相关的服务，建议放到CoreModule中。</li>
<li>SharedModule 中声明(declarations)和导出(exports)所有组件、指令和管道，方便其他模块调用</li>
<li>共享模块（SharedModule）在项目中处于底层，从逻辑上，只能由其他业务逻辑模块调用，不能调用其他模块；</li>
<li>共享模块（SharedModule）不建议使用延迟加载（惰性加载），因为这样会破坏服务的单例特性；</li>
</ol>
<h1 id="3-高级应用-angular库、工作空间（workspace-）"><a href="#3-高级应用-angular库、工作空间（workspace-）" class="headerlink" title="3. 高级应用 - angular库、工作空间（workspace ）"></a>3. 高级应用 - angular库、工作空间（workspace ）</h1><p>想一想你是如何安装angular相关的类库的？我们使用的是<code>npm install xxx</code>。那么这些第三方angular库是如何开发的呢？我们是否可以把通用的内容写成Angular类库，然后方便在多个angular项目间共享了？又或者直接发布到官方npm站点？</p>
<p>Angular 从6.0开始，引入了工作区的概念。使用Angular CLI，默认创建的就是一个工作空间(workspace)。一个工作空间(workspace)可以有一个主项目，同时可以有多个子项目。当然这些子项目可以是angular的application， 也可以是Library。Angular的子项目，都在<code>app</code>下的<code>projects</code> 之下，和<code>src</code>目录平级。</p>
<p>这样，一般来说，我们的项目中，除了主程序，还可以包含多个子类库。这样在开发时方便主程序、类库同时开发调试；也可以项目结束后，单独发布类库，实现项目之间的代码共享。</p>
<p>创建子项目也很简单，子项目有2种类型，application（可以启动的）和Library（Angular类库），默认都在<code>projects</code>文件夹下：</p>
<ol>
<li><p>创建子Applicaton</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng <span class="keyword">generate</span> application &lt;name&gt; [options]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建子类库（Angular Library)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng <span class="keyword">generate</span> <span class="keyword">library</span> &lt;name&gt; [options]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-1-目录结构示意"><a href="#3-1-目录结构示意" class="headerlink" title="3.1. 目录结构示意"></a>3.1. 目录结构示意</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+---projects</span><br><span class="line">|   \---ng-<span class="class"><span class="keyword">lib</span>-<span class="title">a</span></span></span><br><span class="line">|       \---src</span><br><span class="line">|           \---<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">|   \---ng-<span class="class"><span class="keyword">lib</span>-<span class="title">b</span></span></span><br><span class="line">|       \---src</span><br><span class="line">|           \---<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">\---src</span><br><span class="line">    +---app</span><br><span class="line">    |   +---feature1</span><br><span class="line">    |   +---feature2</span><br><span class="line">    |   +---core</span><br><span class="line">    |   |   +---footer</span><br><span class="line">    |   |   \---header</span><br><span class="line">    |   \---shared</span><br><span class="line">    |       +---components</span><br><span class="line">    |       +---pipes</span><br><span class="line">    |       \---services</span><br><span class="line">    +---assets</span><br><span class="line">    \---environments</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol>
<li>Angular CLI默认创建的Angular项目，实际是一个工作空间（workspace ），在其内部还可以创建多个子项目</li>
<li>子项目可以是Application，也可以是类库（Library）；</li>
<li>对于主项目（一般来说是一个Application），以功能模块的方式进行组织；</li>
<li>公共内容，建议放到共享模块-SharedModule中。</li>
<li>对于功能模块，可以通过惰性加载（延迟）加载，提高首页加载速度；同时通过预加载技术，可以在空闲时间加载这部分模块，使用户体验更好。</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/01/29/Angular-Starter-15-folder-structure/" data-id="ckmva0jdg000bpk9xszgadjm8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular入门/">Angular入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-css3-flex-box" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/29/css3-flex-box/" class="article-date">
  <time datetime="2021-01-29T05:06:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/29/css3-flex-box/">CSS3 Flex Box 弹性盒子、弹性布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-概要">1. 概要</a></li>
<li><a href="#2-justify-content-属性">2. justify-content 属性</a></li>
<li><a href="#3-align-items-属性">3. align-items 属性</a></li>
<li><a href="#4-flex-wrap-属性">4. flex-wrap 属性</a></li>
<li><a href="#5-align-content-属性">5. align-content 属性</a></li>
<li><a href="#6-居中">6. 居中</a></li>
<li><a href="#7-align-self">7. align-self</a></li>
<li><a href="#8-总结">8. 总结</a></li>
</ul>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>Flexible Box翻译过来就是弹性盒子、弹性布局，是css3中新增的一种布局方式，是当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>
<p>弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。</p>
<ul>
<li>弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。</li>
<li>弹性容器内包含了一个或多个弹性子元素。</li>
</ul>
<table><br>    <tbody><br>        <tr><br>            <th style="width:25%">属性</th><br>            <th>描述</th><br>        </tr><br>        <tr><br>            <td>display<br>            </td><br>            <td>指定 HTML 元素盒子类型。</td><br>        </tr><br>        <tr><br>            <td>flex-direction</td><br>            <td>指定了弹性容器中子元素的排列方式</td><br>        </tr><br>        <tr><br>            <td>justify-content<br>            </td><br>            <td>设置弹性盒子元素在主轴（横轴）方向上的对齐方式。</td><br>        </tr><br>        <tr><br>            <td>align-items<br>            </td><br>            <td>设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</td><br>        </tr><br>        <tr><br>            <td>flex-wrap<br>            </td><br>            <td>设置弹性盒子的子元素超出父容器时是否换行。</td><br>        </tr><br>        <tr><br>            <td>align-content<br>            </td><br>            <td>修改 flex-wrap 属性的行为，类似align-items, 但不是设置子元素对齐，而是设置行对齐</td><br>        </tr><br>        <tr><br>            <td>flex-flow<br>            </td><br>            <td>flex-direction 和 flex-wrap 的简写</td><br>        </tr><br>        <tr><br>            <td>order<br>            </td><br>            <td>设置弹性盒子的子元素排列顺序。</td><br>        </tr><br>        <tr><br>            <td>align-self<br>            </td><br>            <td>在弹性子元素上使用。覆盖容器的 align-items 属性。</td><br>        </tr><br>        <tr><br>            <td>flex<br>            </td><br>            <td>设置弹性盒子的子元素如何分配空间。</td><br>        </tr><br>    </tbody><br></table>


<h1 id="2-justify-content-属性"><a href="#2-justify-content-属性" class="headerlink" title="2. justify-content 属性"></a>2. justify-content 属性</h1><p>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的横轴（主轴线，main axis）对齐。</p>
<p><code>·justify-content</code> 语法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure></p>
<p>可选项：</p>
<ul>
<li>flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。</li>
<li>flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。</li>
<li>center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</li>
<li>space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</li>
<li>space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。</li>
</ul>
<h1 id="3-align-items-属性"><a href="#3-align-items-属性" class="headerlink" title="3. align-items 属性"></a>3. align-items 属性</h1><p>align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</p>
<p><code>align-items</code>语法<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure></p>
<p>可选项：</p>
<ul>
<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>
<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>
<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>
<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>
<li>stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>
</ul>
<h1 id="4-flex-wrap-属性"><a href="#4-flex-wrap-属性" class="headerlink" title="4. flex-wrap 属性"></a>4. flex-wrap 属性</h1><p>flex-wrap 属性用于指定弹性盒子的子元素换行方式。</p>
<p>语法<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;</span><br></pre></td></tr></table></figure></p>
<p>可选项:</p>
<ul>
<li>nowrap - 默认，弹性容器为单行。该情况下弹性子项可能会溢出容器。</li>
<li>wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li>
<li>wrap-reverse -反转 wrap 排列。</li>
</ul>
<h1 id="5-align-content-属性"><a href="#5-align-content-属性" class="headerlink" title="5. align-content 属性"></a>5. align-content 属性</h1><p><code>align-content</code> 属性用于修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。</p>
<p>语法<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch</span><br></pre></td></tr></table></figure></p>
<p>各个值解析:</p>
<ul>
<li>stretch - 默认。各行将会伸展以占用剩余的空间。</li>
<li>flex-start - 各行向弹性盒容器的起始位置堆叠。</li>
<li>flex-end - 各行向弹性盒容器的结束位置堆叠。</li>
<li>center -各行向弹性盒容器的中间位置堆叠。</li>
<li>space-between -各行在弹性盒容器中平均分布。</li>
<li>space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li>
</ul>
<h1 id="6-居中"><a href="#6-居中" class="headerlink" title="6. 居中"></a>6. 居中</h1><p>使用弹性盒子，居中变的很简单，只想要设置 margin: auto; 可以使得弹性子元素在两上轴方向上完全居中:</p>
<p>如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-align-self"><a href="#7-align-self" class="headerlink" title="7. align-self"></a>7. align-self</h1><p>align-self 属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。</p>
<p>选项：</p>
<ul>
<li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li>
<li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li>
<li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li>
<li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li>
<li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li>
<li>stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li>
</ul>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><ol>
<li><p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/01/29/css3-flex-box/" data-id="ckmva0jfn001bpk9xm4qo0hzx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Angular-Starter-14-compile-publish" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/29/Angular-Starter-14-compile-publish/" class="article-date">
  <time datetime="2021-01-29T02:06:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/29/Angular-Starter-14-compile-publish/">Angular入门到精通系列教程（14）- Angular 编译打包 &amp; Docker发布</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-概要">1. 概要</a></li>
<li><a href="#2-编译打包">2. 编译打包</a><ul>
<li><a href="#21-基本打包命令">2.1. 基本打包命令</a></li>
<li><a href="#22-打包部署到二级目录">2.2. 打包部署到二级目录</a></li>
</ul>
</li>
<li><a href="#3-angular站点的发布">3. Angular站点的发布</a><ul>
<li><a href="#31-web服务器发布">3.1. web服务器发布</a></li>
<li><a href="#32-使用docker发布">3.2. 使用docker发布</a></li>
</ul>
</li>
<li><a href="#4-总结">4. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular CLI: 11.0.6</li>
<li>Angular: 11.0.7</li>
<li>Node: 12.18.3 </li>
<li>npm : 6.14.6</li>
<li>IDE: Visual Studio Code</li>
</ul>
</blockquote>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>当我们完成angular的开发后，如何部署到服务器呢？</p>
<h1 id="2-编译打包"><a href="#2-编译打包" class="headerlink" title="2. 编译打包"></a>2. 编译打包</h1><h2 id="2-1-基本打包命令"><a href="#2-1-基本打包命令" class="headerlink" title="2.1. 基本打包命令"></a>2.1. 基本打包命令</h2><p>基于Angular CLI生成的Angular项目，默认会有2个环境配置文件<br><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└──myProject/src/environments/</span><br><span class="line">               └──<span class="built_in">environment</span>.ts</span><br><span class="line">               └──<span class="built_in">environment</span>.prod.ts</span><br></pre></td></tr></table></figure></p>
<ol>
<li>environment.ts: 针对开发环境使用的环境文件</li>
<li>environment.prod.ts: 生产环境编译时，将替换原有的environment.ts，然后再打包。 （根目录下的angular.json定义了这个默认行为，有需要，可以进行修改）</li>
</ol>
<p>AngularCLI刚刚生成2个文件后，如果打开比较2个文件的区别，可以看到开发环境使用的environment.ts文件中，有这么一句<code>production: false</code>。因为，针对生产环境，angular在编译时需要核心考虑效率等问题，而开发环境，要考虑方便开发者进行调试，侧重点不同。</p>
<p>那么针对生产环境如何编译呢？Angular CLI同样提供了命令,<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build <span class="comment">--prod</span></span><br></pre></td></tr></table></figure></p>
<p>其中，参数<code>--prod</code> 即告诉编译环境，编译为生产环境包。同样，angular.json中定义了默认的编译参数，如果需要，可以进行修改。主要配置参数如下<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"configurations"</span>: &#123;</span><br><span class="line">    <span class="string">"production"</span>: &#123;</span><br><span class="line">        <span class="string">"fileReplacements"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"replace"</span>: <span class="string">"src/environments/environment.ts"</span>,</span><br><span class="line">            <span class="string">"with"</span>: <span class="string">"src/environments/environment.prod.ts"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"optimization"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"outputHashing"</span>: <span class="string">"all"</span>,</span><br><span class="line">        <span class="string">"sourceMap"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"extractCss"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"namedChunks"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"aot"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"extractLicenses"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"vendorChunk"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"buildOptimizer"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"budgets"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"initial"</span>,</span><br><span class="line">            <span class="string">"maximumWarning"</span>: <span class="string">"5mb"</span>,</span><br><span class="line">            <span class="string">"maximumError"</span>: <span class="string">"10mb"</span></span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Angular默认打包到根目录下的<code>dist</code>目录下，生成的文件为纯静态文件（html, css, js)，以及图片文件。</p>
<h2 id="2-2-打包部署到二级目录"><a href="#2-2-打包部署到二级目录" class="headerlink" title="2.2. 打包部署到二级目录"></a>2.2. 打包部署到二级目录</h2><p>有不少情况，我们的angular web站点不能直接部署到网站的根目录下，需要部署到二级目录下。 比如，不能部署到 <a href="http://abc.com下，要求部署到" target="_blank" rel="noopener">http://abc.com下，要求部署到</a> <a href="http://abc.com/demo" target="_blank" rel="noopener">http://abc.com/demo</a> 这个二级目录下。针对这种情况，就需要修改一下我们的编译参数，修改为：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build <span class="params">--prod</span> <span class="params">--deploy-url</span> <span class="string">/demo/</span> <span class="params">--base-href</span> <span class="string">/demo/</span></span><br></pre></td></tr></table></figure></p>
<p>增加 <code>--deploy-url</code> 和 <code>--base-href</code>。</p>
<blockquote>
<p>使用场景：比如我们有多个站点，希望使用同一个反向代理， <code>http://site1</code>, <code>http://site2</code>, 分别映射到 <code>http://abc.com/site1</code>, <code>http://abc.com/site2/</code>。 那么为了方便配置，需要把site1， site2都部署到二级目录，如<code>http://site1/site1</code>, <code>http://site2/site2</code>。 然后 <code>http://site1/site1</code>代理到<code>http://abc.com/site1</code>, <code>http://site2/site2</code>代理到<code>http://abc.com/site2/</code>， 免得css、js因为目录级别问题找不到。</p>
</blockquote>
<h1 id="3-Angular站点的发布"><a href="#3-Angular站点的发布" class="headerlink" title="3. Angular站点的发布"></a>3. Angular站点的发布</h1><p>Angular站点编译打包后，可以方便的发布到已有web服务器，或者打成docker image， 然后发布。</p>
<h2 id="3-1-web服务器发布"><a href="#3-1-web服务器发布" class="headerlink" title="3.1. web服务器发布"></a>3.1. web服务器发布</h2><p>因为我们打包后，生成的文件为纯静态文件（html, css, js, 图片等)， 所以打包后的问题，可以直接copy到iis， nginx , apache tomcat等web服务器，或者node.js， java等可以显示静态文件的程序的目录下即可。</p>
<h2 id="3-2-使用docker发布"><a href="#3-2-使用docker发布" class="headerlink" title="3.2. 使用docker发布"></a>3.2. 使用docker发布</h2><p>如果部署到docker，我们可以基于一个基础的nginx docker， 然后把编译好的angular项目，copy到docker 内的nginx目录下即可。</p>
<p>基本步骤：</p>
<ol>
<li>准备Dockerfile 文件， docker可以基于<code>nginx:alpine</code>， 将编译好的angular 站点文件复制到 docker 的nginx默认目录 <code>/usr/share/nginx/html</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:alpine</span><br><span class="line">COPY . /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： 1) 假设angular打包后的文件，与Dockerfile文件在同一个目录<br>2) COPY . /usr/share/nginx/html, 两个参数 <code>.</code> 代表当前路径， <code>/usr/share/nginx/html</code>是docker中的目标目录</p>
</blockquote>
<ol start="2">
<li>编译docker。 在Dockerfile目录下，执行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your-docker-name .</span><br><span class="line">docker save your-docker-name &gt; your-docker-name.tar</span><br><span class="line">gzip your-docker-name.tar</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>三条命令分别为：</p>
<ul>
<li>生成docker image， 名字（name）为your-docker-name</li>
<li>导出docker image为本地文件， 文件名为 your-docker-name.tar</li>
<li>压缩docker image</li>
</ul>
<p>可以看到，因为angular编译后为纯静态文件，所以使用docker发布非常简单。部署时，只需要复制docker文件到目标机器，解压缩，然后执行  <code>docker load &lt; your-docker-name.tar</code> 即可加载docker image到目标机器。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol>
<li>为生产环境编译，一定要加参数<code>--prod</code></li>
<li>如果要部署到二级目录，编译时加参数。如部署到/demo二级目录下，加参数： <code>--deploy-url /demo/ --base-href /demo/</code></li>
<li>使用docker发布,可以选择基本的nginx docker， 然后将编译好的angular文件copy到nginx目录下即可。</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/01/29/Angular-Starter-14-compile-publish/" data-id="ckmva0jdg000apk9xhi7rn0zt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular入门/">Angular入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Angular-Starter-13-gard-routing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/25/Angular-Starter-13-gard-routing/" class="article-date">
  <time datetime="2021-01-25T07:06:00.000Z" itemprop="datePublished">2021-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/25/Angular-Starter-13-gard-routing/">Angular入门到精通系列教程（13）- 路由守卫（Route Guards）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-摘要">1. 摘要</a></li>
<li><a href="#2-路由守卫route-guards">2. 路由守卫（Route Guards）</a><ul>
<li><a href="#21-创建路由守卫">2.1. 创建路由守卫</a></li>
<li><a href="#22-控制路由是否可以激活">2.2. 控制路由是否可以激活</a></li>
<li><a href="#23-控制路由是否退出离开">2.3. 控制路由是否退出（离开）</a></li>
</ul>
</li>
<li><a href="#3-总结">3. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular CLI: 11.0.6</li>
<li>Angular: 11.0.7</li>
<li>Node: 12.18.3 </li>
<li>npm : 6.14.6</li>
<li>IDE: Visual Studio Code</li>
</ul>
</blockquote>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>在我们的实际的业务开发过程中，我们经常会遇到如下需求：</p>
<ol>
<li>需要限制某些 URL 的可访问性，例如，对于系统管理界面，只有那些拥有管理员权限的用户才能打开。</li>
<li>当用户处于编辑界面时，在没有保存就离开时，需要提示用户是否放弃修改。</li>
</ol>
<p>针对以上场景，Angualr使用<code>路由守卫</code>（Route Guards）来实现。</p>
<h1 id="2-路由守卫（Route-Guards）"><a href="#2-路由守卫（Route-Guards）" class="headerlink" title="2. 路由守卫（Route Guards）"></a>2. 路由守卫（Route Guards）</h1><h2 id="2-1-创建路由守卫"><a href="#2-1-创建路由守卫" class="headerlink" title="2.1. 创建路由守卫"></a>2.1. 创建路由守卫</h2><p>Angular CLI提供了命令行工具，可以快速创建路由守卫框架文件：<code>ng generate guard auth</code>。 执行后，Angular CLI会问我们需要实现哪些接口，我们直接勾选即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Which interfaces would you like to implement? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">(*) CanActivate</span></span><br><span class="line"> ( ) CanActivateChild</span><br><span class="line"> ( ) CanDeactivate</span><br><span class="line"> ( ) CanLoad</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>CanActivate: 控制路由是否可以激活</li>
<li>CanActivateChild: 控制子路由是否可以激活</li>
<li>CanDeactivate: 控制路由是否可以退出</li>
<li>CanLoad: 控制模块（module）是否可以被加载</li>
</ol>
<p>比较经常使用的是1、3，分别控制进入和退出。 按照上面配置，AngularCLI自动生成如下代码，<code>return true;</code> 替换为我们实际的代码即可。<code>return false;</code> 表示不允许跳转，或者取消离开当前页面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth.guard.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CanActivate, CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthGuard <span class="keyword">implements</span> CanActivate, CanDeactivate&lt;unknown&gt; &#123;</span><br><span class="line">  canActivate(</span><br><span class="line">    route: ActivatedRouteSnapshot,</span><br><span class="line">    state: RouterStateSnapshot): Observable&lt;<span class="built_in">boolean</span> | UrlTree&gt; | <span class="built_in">Promise</span>&lt;<span class="built_in">boolean</span> | UrlTree&gt; | <span class="built_in">boolean</span> | UrlTree &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在canActivate方法中，我们还可以使用跳转。如页面判断是否已经登录，如果没有登录，跳转到Login页面：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.router.navigate([<span class="string">'/login'</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-控制路由是否可以激活"><a href="#2-2-控制路由是否可以激活" class="headerlink" title="2.2. 控制路由是否可以激活"></a>2.2. 控制路由是否可以激活</h2><p>控制路由是否可以激活，需要定义在定义路由的地方，增加canActivate属性。如果需要，还可以增加data属性， 比如告诉我们的AuthGuard进入当前路由需要验证哪些权限。data属性是可选的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"page1"</span>,</span><br><span class="line">    component: Page1Component,</span><br><span class="line">    data: &#123; permissions: [<span class="string">'YourPage1Permission'</span>] &#125;,  <span class="comment">// 传入参数给AuthGuard，可选</span></span><br><span class="line">    canActivate: [AuthGuard]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"page2"</span>,</span><br><span class="line">    component: Page2omponent,</span><br><span class="line">    data: &#123; permissions: [<span class="string">'YourPage2Permission'</span>] &#125;,  <span class="comment">// 传入参数给AuthGuard，可选</span></span><br><span class="line">    canActivate: [AuthGuard]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-控制路由是否退出（离开）"><a href="#2-3-控制路由是否退出（离开）" class="headerlink" title="2.3. 控制路由是否退出（离开）"></a>2.3. 控制路由是否退出（离开）</h2><p>和控制路由是否可以激活类似，在路由定义出增加 <code>canDeactivate</code>，并制定相应的Guard守卫即可。这里不再举例</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol>
<li>通过路由守卫（Route Guards）实现控制URL的进入和离开;</li>
<li>Angular CLI可以辅助我们创建guard文件;</li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/01/25/Angular-Starter-13-gard-routing/" data-id="ckmva0jdg0008pk9xyjmvpp5s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular入门/">Angular入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Angular-Starter-12-routing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/25/Angular-Starter-12-routing/" class="article-date">
  <time datetime="2021-01-25T02:06:00.000Z" itemprop="datePublished">2021-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/25/Angular-Starter-12-routing/">Angular入门到精通系列教程（12）- 路由（Routing）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-摘要">1. 摘要</a></li>
<li><a href="#2-路由router基本用法">2. 路由（Router）基本用法</a><ul>
<li><a href="#21-准备">2.1. 准备</a></li>
<li><a href="#22-注册路由">2.2. 注册路由</a></li>
<li><a href="#23-html中的用法">2.3. html中的用法</a></li>
<li><a href="#24-ts-代码中的用法">2.4. ts 代码中的用法</a></li>
</ul>
</li>
<li><a href="#3-接收参数">3. 接收参数</a><ul>
<li><a href="#31-路径中的参数">3.1. 路径中的参数</a></li>
<li><a href="#32-参数queryparameter中的参数">3.2. 参数（QueryParameter）中的参数</a></li>
</ul>
</li>
<li><a href="#4-url路径显示格式">4. URL路径显示格式</a></li>
<li><a href="#5-部署中遇到的问题">5. 部署中遇到的问题</a></li>
<li><a href="#6-总结">6. 总结</a></li>
</ul>
<blockquote>
<p>环境: </p>
<ul>
<li>Angular CLI: 11.0.6</li>
<li>Angular: 11.0.7</li>
<li>Node: 12.18.3 </li>
<li>npm : 6.14.6</li>
<li>IDE: Visual Studio Code</li>
</ul>
</blockquote>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>简单来说地址栏中，不同的地址（URL）对应不同的页面，这就是路由。同时，点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航，这也是基于路由。</p>
<p>在 Angular 里面，Router 是一个独立的模块，定义在 @angular/router 模块中，</p>
<ol>
<li>Router 可以配合 NgModule 进行模块的延迟加载（懒加载）、预加载操作（参考《Angular入门到精通系列教程（11）- 模块(NgModule)，延迟加载模块》）；</li>
<li>Router 会管理组件的生命周期，它会负责创建、销毁组件。</li>
</ol>
<p>对于一个新的基于AngularCLI的项目，初始化时可以通过选项，将AppRoutingModule默认加入到app.component.ts中。</p>
<h1 id="2-路由（Router）基本用法"><a href="#2-路由（Router）基本用法" class="headerlink" title="2. 路由（Router）基本用法"></a>2. 路由（Router）基本用法</h1><h2 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1. 准备"></a>2.1. 准备</h2><p>我们首先创建2个页面，用于说明路由的使用：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ng g <span class="keyword">c</span> page<span class="number">1</span></span><br><span class="line">ng g <span class="keyword">c</span> page<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>使用上面AnuglarCLI命令，创建Page1Component, Page2Component 2个组件。</p>
<h2 id="2-2-注册路由"><a href="#2-2-注册路由" class="headerlink" title="2.2. 注册路由"></a>2.2. 注册路由</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src\app\app-routing.module.ts</span></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'page1'</span>,</span><br><span class="line">    component: Page1Component</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'page2'</span>,</span><br><span class="line">    component: Page2Component</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，简单的路由注册，只需要path和component2个属性，分别定义路由的相对路径，以及这个路由的响应组件。</p>
<h2 id="2-3-html中的用法"><a href="#2-3-html中的用法" class="headerlink" title="2.3. html中的用法"></a>2.3. html中的用法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page1"</span>&gt;</span>Page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"page2"</span>&gt;</span>Page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在html模板中，直接使用routerLink属性，标识为angular的路由。执行代码，可以看到 Page1和Page2 两个超链接，点击可以看到地址栏地址改为<a href="http://localhost:4200/page2或http://localhost:4200/page1，" target="_blank" rel="noopener">http://localhost:4200/page2或http://localhost:4200/page1，</a> 页面内容在page1和page2中切换</p>
<h2 id="2-4-ts-代码中的用法"><a href="#2-4-ts-代码中的用法" class="headerlink" title="2.4. ts 代码中的用法"></a>2.4. ts 代码中的用法</h2><p>有时候，需要根据ts中的业务逻辑，进行跳转。ts中，需要注入Router实例，如<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>跳转代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到 /page1</span></span><br><span class="line"><span class="keyword">this</span>.router.navigate([<span class="string">'/page1'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到 /page1/123</span></span><br><span class="line"><span class="keyword">this</span>.router.navigate([<span class="string">'/page1'</span>, <span class="number">123</span>]);</span><br></pre></td></tr></table></figure></p>
<h1 id="3-接收参数"><a href="#3-接收参数" class="headerlink" title="3. 接收参数"></a>3. 接收参数</h1><h2 id="3-1-路径中的参数"><a href="#3-1-路径中的参数" class="headerlink" title="3.1. 路径中的参数"></a>3.1. 路径中的参数</h2><p>一般来说，我们把参数作为url中的一段，如/users/1, 代表查询id是1的用户，路由定义为”/users/id” 这种风格。</p>
<p>针对我们的简单页面，比如我们的page1页面可以传id参数，那么我们需要修改我们的routing为：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'page1/:id'</span>,    <span class="comment">//接收id参数</span></span><br><span class="line">    component: Page1Component,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 实现可选参数的小技巧。 这个routing处理没有参数的url</span></span><br><span class="line">    path: <span class="string">'page1'</span>,        </span><br><span class="line">    redirectTo: <span class="string">'page1/'</span>,   <span class="comment">// 跳转到'page1/:id'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'page2'</span>,</span><br><span class="line">    component: Page2Component,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>ts代码读取参数时， 首先需要注入ActivatedRoute，代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> activatedRoute: ActivatedRoute</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">ngOnInit(): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.activatedRoute.paramMap.subscribe(<span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Parameter id: '</span>, params.get(<span class="string">'id'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址 http://localhost:4200/page1/33   </span></span><br><span class="line">    <span class="comment">// 控制台输出：Query Parameter name:  33</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址 http://localhost:4200/page1/     </span></span><br><span class="line">    <span class="comment">// 控制台输出：Query Parameter name:   (实际结果为undefined)</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-参数（QueryParameter）中的参数"><a href="#3-2-参数（QueryParameter）中的参数" class="headerlink" title="3.2. 参数（QueryParameter）中的参数"></a>3.2. 参数（QueryParameter）中的参数</h2><p>参数还有另外一种写法，如<a href="http://localhost:4200/?name=cat" target="_blank" rel="noopener">http://localhost:4200/?name=cat</a>, 即URL地址后，加一个问号’?’, 之后再加参数名和参数值（’name=cat’）。这种称为查询参数(QueryParameter)。</p>
<p>取这查询参数时，和之前的路由参数类似，只是paramMap改为queryParamMap，代码如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.activatedRoute.queryParamMap.subscribe(<span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Query Parameter name: '</span>, params.get(<span class="string">'name'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 地址 http://localhost:4200/page1?name=cat</span></span><br><span class="line">  <span class="comment">// 控制台输出：Query Parameter name:  cat</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 地址 http://localhost:4200/page1/</span></span><br><span class="line">  <span class="comment">// 控制台输出：Query Parameter name:   (实际结果为undefined)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="4-URL路径显示格式"><a href="#4-URL路径显示格式" class="headerlink" title="4. URL路径显示格式"></a>4. URL路径显示格式</h1><p>不同于传统的纯静态（html）站点，angular中的url不是对应一个真实的文件（页面），因为anuglar接管的路由（Routing）处理，来决定显示那个Component给终端用户。为了针对不同的场景，angular的URL路径显示格式有2中：</p>
<ol>
<li><a href="http://localhost:4200/page1/123" target="_blank" rel="noopener">http://localhost:4200/page1/123</a></li>
<li><a href="http://localhost:4200/#/page1/123" target="_blank" rel="noopener">http://localhost:4200/#/page1/123</a></li>
</ol>
<p>默认是第一种，不加#的。如果需要，可以在app-routing.ts中，加入<code>useHash: true</code>, 如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app-routing.ts</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes, &#123; useHash: <span class="literal">true</span> &#125;)],</span><br><span class="line">  exports: [RouterModule],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="5-部署中遇到的问题"><a href="#5-部署中遇到的问题" class="headerlink" title="5. 部署中遇到的问题"></a>5. 部署中遇到的问题</h1><p>同样，因为anuglar接管的路由（Routing）处理，所以部署时，部署到iis, nginx等等的服务器，都会有不同的技巧（要求），详细参考：<br><a href="https://github.com/angular-ui/ui-router/wiki/Frequently-Asked-Questions#how-to-configure-your-server-to-work-with-html5mode" target="_blank" rel="noopener">https://github.com/angular-ui/ui-router/wiki/Frequently-Asked-Questions#how-to-configure-your-server-to-work-with-html5mode</a></p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><ol>
<li>angular默认不支持可选路由（e.g. /user/:id?),但是我们可以定义2个路由，指向同一个Component来实现这个，达到代码复用；（或者使用redirectTo）</li>
<li>可以使用useHash参数，实现augular路径前加一个#；</li>
<li>读取参数时，都需要subscribe订阅一下，不能直接读取。</li>
<li>打包后部署问题，查看官方wifi （<a href="https://github.com/angular-ui/ui-router/wiki/Frequently-Asked-Questions#how-to-configure-your-server-to-work-with-html5mode）" target="_blank" rel="noopener">https://github.com/angular-ui/ui-router/wiki/Frequently-Asked-Questions#how-to-configure-your-server-to-work-with-html5mode）</a></li>
</ol>
<p><br><br></p>
<blockquote>
<p>—————- END —————-</p>
</blockquote>
<p><br><br><br><br><br></p>
<blockquote>
<p>======================</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="jackniu81.github.io/2021/01/25/Angular-Starter-12-routing/" data-id="ckmva0jd10005pk9xrwkjwlq9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular入门/">Angular入门</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
        <aside id="sidebar">

<div class="widget-wrap">
    <h3 class="widget-title">Recommended</h3>
    <div class="widget">
      <ul>
        <li><a href="/css">CSS Tips</a></li>
        <li><a href="/javascript">javascript Tips</a></li>
        <li><a href="/node-js">Node.js Tips</a></li>
      </ul>
    </div>
  </div>
  
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular入门/">Angular入门</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assemble/">Assemble</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kubernetes/">Kubernetes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metalsmith/">Metalsmith</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL-Server/">SQL Server</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wintersmith/">Wintersmith</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iframe/">iframe</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js-面试题/">node.js - 面试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 20px;">Angular</a> <a href="/tags/Angular入门/" style="font-size: 16.67px;">Angular入门</a> <a href="/tags/Assemble/" style="font-size: 10px;">Assemble</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Kubernetes/" style="font-size: 10px;">Kubernetes</a> <a href="/tags/Metalsmith/" style="font-size: 10px;">Metalsmith</a> <a href="/tags/SQL-Server/" style="font-size: 10px;">SQL Server</a> <a href="/tags/Wintersmith/" style="font-size: 10px;">Wintersmith</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/mobile/" style="font-size: 10px;">mobile</a> <a href="/tags/node-js/" style="font-size: 10px;">node.js</a> <a href="/tags/node-js-面试题/" style="font-size: 10px;">node.js - 面试题</a> <a href="/tags/面试/" style="font-size: 13.33px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/07/CSS-interview-qa/">CSS面试题汇总</a>
          </li>
        
          <li>
            <a href="/2021/03/02/node-js-interview-qa/">node.js 面试题总结</a>
          </li>
        
          <li>
            <a href="/2021/03/02/mobile-ux-performance/">移动端如何做好用户体验</a>
          </li>
        
          <li>
            <a href="/2021/02/09/Angular-keyword/">Angular 词汇表</a>
          </li>
        
          <li>
            <a href="/2021/02/07/js-speical/">javascript中常见的非人类（java/c#)知识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Jack
      |
      <a href="https://hexo.io">HEXO</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>

</html>